<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>impy.arrays.imgarray &mdash; impy 2.2.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> impy
          </a>
              <div class="version">
                2.2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_axes.html">Axes in impy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_cmd.html">Command Line Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">impy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>impy.arrays.imgarray</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for impy.arrays.imgarray</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span> <span class="k">as</span> <span class="n">ndi</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Callable</span>

<span class="kn">from</span> <span class="nn">.labeledarray</span> <span class="kn">import</span> <span class="n">LabeledArray</span>
<span class="kn">from</span> <span class="nn">.label</span> <span class="kn">import</span> <span class="n">Label</span>
<span class="kn">from</span> <span class="nn">.phasearray</span> <span class="kn">import</span> <span class="n">PhaseArray</span>
<span class="kn">from</span> <span class="nn">.specials</span> <span class="kn">import</span> <span class="n">PropArray</span>

<span class="kn">from</span> <span class="nn">._utils._skimage</span> <span class="kn">import</span> <span class="n">skexp</span><span class="p">,</span> <span class="n">skfeat</span><span class="p">,</span> <span class="n">skfil</span><span class="p">,</span> <span class="n">skimage</span><span class="p">,</span> <span class="n">skmes</span><span class="p">,</span> <span class="n">skres</span><span class="p">,</span> <span class="n">skseg</span><span class="p">,</span> <span class="n">sktrans</span>
<span class="kn">from</span> <span class="nn">._utils</span> <span class="kn">import</span> <span class="n">_filters</span><span class="p">,</span> <span class="n">_linalg</span><span class="p">,</span> <span class="n">_deconv</span><span class="p">,</span> <span class="n">_misc</span><span class="p">,</span> <span class="n">_glcm</span><span class="p">,</span> <span class="n">_docs</span><span class="p">,</span> <span class="n">_transform</span><span class="p">,</span> <span class="n">_structures</span><span class="p">,</span> <span class="n">_corr</span>

<span class="kn">from</span> <span class="nn">..utils.axesop</span> <span class="kn">import</span> <span class="n">add_axes</span><span class="p">,</span> <span class="n">switch_slice</span><span class="p">,</span> <span class="n">complement_axes</span><span class="p">,</span> <span class="n">find_first_appeared</span>
<span class="kn">from</span> <span class="nn">..utils.deco</span> <span class="kn">import</span> <span class="n">check_input_and_output</span><span class="p">,</span> <span class="n">dims_to_spatial_axes</span><span class="p">,</span> <span class="n">same_dtype</span>
<span class="kn">from</span> <span class="nn">..utils.gauss</span> <span class="kn">import</span> <span class="n">GaussianBackground</span><span class="p">,</span> <span class="n">GaussianParticle</span>
<span class="kn">from</span> <span class="nn">..utils.misc</span> <span class="kn">import</span> <span class="n">check_nd</span><span class="p">,</span> <span class="n">largest_zeros</span>
<span class="kn">from</span> <span class="nn">..utils.slicer</span> <span class="kn">import</span> <span class="n">solve_slicer</span>

<span class="kn">from</span> <span class="nn">..collections</span> <span class="kn">import</span> <span class="n">DataDict</span>
<span class="kn">from</span> <span class="nn">..axes</span> <span class="kn">import</span> <span class="n">AxisLike</span><span class="p">,</span> <span class="n">slicer</span><span class="p">,</span> <span class="n">Axes</span><span class="p">,</span> <span class="n">Axis</span>
<span class="kn">from</span> <span class="nn">.._types</span> <span class="kn">import</span> <span class="n">nDInt</span><span class="p">,</span> <span class="n">nDFloat</span><span class="p">,</span> <span class="n">Dims</span><span class="p">,</span> <span class="n">Coords</span><span class="p">,</span> <span class="n">AxesTargetedSlicer</span><span class="p">,</span> <span class="n">PaddingMode</span>
<span class="kn">from</span> <span class="nn">.._const</span> <span class="kn">import</span> <span class="n">Const</span>
<span class="kn">from</span> <span class="nn">..array_api</span> <span class="kn">import</span> <span class="n">xp</span><span class="p">,</span> <span class="n">cupy_dispatcher</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">..frame</span> <span class="kn">import</span> <span class="n">MarkerFrame</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Union</span>
    <span class="n">ThreasholdMethod</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;isodata&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;li&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;local&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">],</span>
        <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;minimum&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;niblack&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;otsu&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;sauvola&quot;</span><span class="p">],</span> 
        <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;triangle&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;yen&quot;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">FftShape</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;same&quot;</span><span class="p">,</span> <span class="s2">&quot;square&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="ImgArray"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray">[docs]</a><span class="k">class</span> <span class="nc">ImgArray</span><span class="p">(</span><span class="n">LabeledArray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An n-D array for image analysis.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    axes : str</span>
<span class="sd">        Image axes, such as &quot;zyx&quot; or &quot;tcyx&quot;.</span>
<span class="sd">    scale : ScaleDict</span>
<span class="sd">        Physical scale along each axis. For instance, scale of x-axis can be referred </span>
<span class="sd">        to by ``img.scale[&quot;x&quot;]`` or ``img.scale.x</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        Metadata tagged to the image.</span>
<span class="sd">    source : Path</span>
<span class="sd">        Source file of the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ImgArray.affine"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.affine">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">affine</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shear</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">output_shape</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefilter</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert image by Affine transformation. 2D Affine transformation is written as:</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            \begin{bmatrix} y&#39;\\ x&#39; \\1 \end{bmatrix} =</span>
<span class="sd">            \begin{bmatrix} A_{00} &amp; A_{01} &amp; A_{02} \\</span>
<span class="sd">                            A_{10} &amp; A_{11} &amp; A_{12} \\</span>
<span class="sd">                                0 &amp;      0 &amp;      1  \end{bmatrix}</span>
<span class="sd">                            \begin{bmatrix} y \\x\\ 1 \end{bmatrix}</span>
<span class="sd">           </span>
<span class="sd">          </span>
<span class="sd">        and similarly, n-D Affine transformation can be described as (n+1)-D matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix, scale, rotation, shear, translation</span>
<span class="sd">            Affine transformation parameters. See ``skimage.transform.AffineTransform`` for details.</span>
<span class="sd">        {order}{mode}{cval}</span>
<span class="sd">        output_shape : tuple of int, optional</span>
<span class="sd">            Shape of output array.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Transformed image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">and</span> <span class="n">output_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot update image when output_shape is provided.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cval</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cval</span><span class="p">):</span>
            <span class="n">cval</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cval</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">cval</span><span class="p">):</span>
            <span class="n">cval</span> <span class="o">=</span> <span class="n">cval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        
        <span class="n">prefilter</span> <span class="o">=</span> <span class="n">prefilter</span> <span class="ow">or</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">translation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">matrix</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">shear</span><span class="p">]):</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
                <span class="n">_transform</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span>
                <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">,</span> <span class="n">prefilter</span><span class="o">=</span><span class="n">prefilter</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">_transform</span><span class="o">.</span><span class="n">compose_affine_matrix</span><span class="p">(</span>
                <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span> <span class="n">shear</span><span class="o">=</span><span class="n">shear</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="n">translation</span><span class="p">,</span>
                <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_transform</span><span class="o">.</span><span class="n">warp</span><span class="p">,</span>
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">,</span>
                        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span> <span class="n">prefilter</span><span class="o">=</span><span class="n">prefilter</span><span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.rotate"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.rotate">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">degree</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        2D rotation of an image around a point. Outside will be padded with zero. For n-D images,</span>
<span class="sd">        this implementation is faster than ``scipy.ndimage.rotate``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        degree : float</span>
<span class="sd">            Clockwise degree of rotation. Not radian.</span>
<span class="sd">        center : str or array-like, optional</span>
<span class="sd">            Rotation center coordinate. By default the center of image will be the rotation center.</span>
<span class="sd">        {order}{mode}{cval}{dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Rotated image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span><span class="o">/</span><span class="mf">2.</span> <span class="o">-</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
            
        <span class="n">translation_0</span> <span class="o">=</span> <span class="n">_transform</span><span class="o">.</span><span class="n">compose_affine_matrix</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">_transform</span><span class="o">.</span><span class="n">compose_affine_matrix</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">degree</span><span class="p">))</span>
        <span class="n">translation_1</span> <span class="o">=</span> <span class="n">_transform</span><span class="o">.</span><span class="n">compose_affine_matrix</span><span class="p">(</span><span class="n">translation</span><span class="o">=-</span><span class="n">center</span><span class="p">)</span>
        
        <span class="n">mx</span> <span class="o">=</span> <span class="n">translation_0</span> <span class="o">@</span> <span class="n">rotation</span> <span class="o">@</span> <span class="n">translation_1</span>
        <span class="n">mx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_transform</span><span class="o">.</span><span class="n">warp</span><span class="p">,</span>
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">mx</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">),</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.stretch"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.stretch">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">stretch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="n">nDFloat</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> 
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        2D stretching of an image from a point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale: array-like</span>
<span class="sd">            Stretch factors.</span>
<span class="sd">        center : str or array-like, optional</span>
<span class="sd">            Rotation center coordinate. By default the center of image will be the rotation center.</span>
<span class="sd">        {mode}{cval}{dims}{order}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Stretched image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span><span class="o">/</span><span class="mf">2.</span> <span class="o">-</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
        
        <span class="n">scale</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        
        <span class="n">translation_0</span> <span class="o">=</span> <span class="n">_transform</span><span class="o">.</span><span class="n">compose_affine_matrix</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>
        <span class="n">stretch</span> <span class="o">=</span> <span class="n">_transform</span><span class="o">.</span><span class="n">compose_affine_matrix</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scale</span><span class="p">))</span>
        <span class="n">translation_1</span> <span class="o">=</span> <span class="n">_transform</span><span class="o">.</span><span class="n">compose_affine_matrix</span><span class="p">(</span><span class="n">translation</span><span class="o">=-</span><span class="n">center</span><span class="p">)</span>
        
        <span class="n">mx</span> <span class="o">=</span> <span class="n">translation_0</span> <span class="o">@</span> <span class="n">stretch</span> <span class="o">@</span> <span class="n">translation_1</span>
        <span class="n">mx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_transform</span><span class="o">.</span><span class="n">warp</span><span class="p">,</span>
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">mx</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ImgArray.rescale"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.rescale">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rescale</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">16</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rescale image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale : float, optional</span>
<span class="sd">            scale of the new image.</span>
<span class="sd">        {order}{mode}{cval}{dims}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Rescaled image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">outshape</span> <span class="o">=</span> <span class="n">switch_slice</span><span class="p">(</span>
            <span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">ifin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="n">ifnot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span>
        <span class="n">gb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">outshape</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="o">/</span><span class="mf">1e9</span>
        <span class="k">if</span> <span class="n">gb</span> <span class="o">&gt;</span> <span class="n">Const</span><span class="p">[</span><span class="s2">&quot;MAX_GB&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too large: </span><span class="si">{</span><span class="n">gb</span><span class="si">}</span><span class="s2"> GB&quot;</span><span class="p">)</span>
        <span class="n">scale_</span> <span class="o">=</span> <span class="p">[</span><span class="n">scale</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">sktrans</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">scale_</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">ImgArray</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">set_scale</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">/</span><span class="n">scale</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">scale_</span><span class="p">)})</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.binning"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.binning">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span>
    <span class="k">def</span> <span class="nf">binning</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">binsize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">check_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Binning of images. This function is similar to ``rescale`` but is strictly </span>
<span class="sd">        binned by :math:`N \times N` blocks. Also, any numpy functions that accept </span>
<span class="sd">        &quot;axis&quot; argument are supported for reduce functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        binsize : int, default is 2</span>
<span class="sd">            Bin size, such as 2x2.</span>
<span class="sd">        method : str or callable, default is numpy.mean</span>
<span class="sd">            Reduce function applied to each bin.</span>
<span class="sd">        check_edges : bool, default is True</span>
<span class="sd">            If True, only divisible ``binsize`` is accepted. If False, image is</span>
<span class="sd">            cropped at the end to match `binsize`.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Binned image</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">binfunc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
            <span class="n">binfunc</span> <span class="o">=</span> <span class="n">method</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`method` must be a numpy function or callable object.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">binsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">img_to_reshape</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">scale_</span> <span class="o">=</span> <span class="n">_misc</span><span class="o">.</span><span class="n">adjust_bin</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">check_edges</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        <span class="p">)</span>
        
        <span class="n">reshaped_img</span> <span class="o">=</span> <span class="n">img_to_reshape</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">axes_to_reduce</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">binfunc</span><span class="p">(</span><span class="n">reshaped_img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes_to_reduce</span><span class="p">)</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">ImgArray</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span> <span class="c1"># _set_info does not pass copy so new axes must be defined here.</span>
        <span class="n">out</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span>
            <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">/</span><span class="n">scale</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">scale_</span><span class="p">)}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.radial_profile"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.radial_profile">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="k">def</span> <span class="nf">radial_profile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nbin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">r_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PropArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate radial profile of images. Scale along each axis will be considered, </span>
<span class="sd">        i.e., rather ellipsoidal profile will be calculated instead if scales are</span>
<span class="sd">        different between axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nbin : int, default is 32</span>
<span class="sd">            Number of bins.</span>
<span class="sd">        center : iterable of float, optional</span>
<span class="sd">            The coordinate of center of radial profile. By default, the center of image</span>
<span class="sd">            is used.</span>
<span class="sd">        r_max : float, optional</span>
<span class="sd">            Maximum radius to make profile. Region 0 &lt;= r &lt; r_max will be split into </span>
<span class="sd">            ``nbin`` rings (or shells). **Scale must be considered** because scales of </span>
<span class="sd">            each axis may vary.</span>
<span class="sd">        method : str, default is &quot;mean&quot;</span>
<span class="sd">            Reduce function. Basic statistics functions are supported in ``scipy.ndimage``</span>
<span class="sd">            but their names are not consistent with those in `numpy`. Use `numpy`&#39;s names</span>
<span class="sd">            here.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PropArray</span>
<span class="sd">            Radial profile stored in x-axis by default. If input image has tzcyx-axes, then an array </span>
<span class="sd">            with tcx-axes will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">func</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">xp</span><span class="o">.</span><span class="n">ndi</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
                <span class="s2">&quot;sum&quot;</span><span class="p">:</span> <span class="n">xp</span><span class="o">.</span><span class="n">ndi</span><span class="o">.</span><span class="n">sum_labels</span><span class="p">,</span>
                <span class="s2">&quot;median&quot;</span><span class="p">:</span> <span class="n">xp</span><span class="o">.</span><span class="n">ndi</span><span class="o">.</span><span class="n">median</span><span class="p">,</span>
                <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="n">xp</span><span class="o">.</span><span class="n">ndi</span><span class="o">.</span><span class="n">maximum</span><span class="p">,</span>
                <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="n">xp</span><span class="o">.</span><span class="n">ndi</span><span class="o">.</span><span class="n">minimum</span><span class="p">,</span>
                <span class="s2">&quot;std&quot;</span><span class="p">:</span> <span class="n">xp</span><span class="o">.</span><span class="n">ndi</span><span class="o">.</span><span class="n">standard_deviation</span><span class="p">,</span>
                <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="n">xp</span><span class="o">.</span><span class="n">ndi</span><span class="o">.</span><span class="n">variance</span><span class="p">}[</span><span class="n">method</span><span class="p">]</span>
        
        <span class="n">spatial_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">spatial_shape</span><span class="p">)</span>
        
        <span class="c1"># check center</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">/</span><span class="mi">2</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spatial_shape</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">center</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Length of `center` must match input dimensionality &#39;</span><span class="si">{</span><span class="n">dims</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span>
        
        <span class="n">r</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">(((</span><span class="n">x</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">a</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">dims</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">r_lim</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        
        <span class="c1"># check r_max</span>
        <span class="k">if</span> <span class="n">r_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r_max</span> <span class="o">=</span> <span class="n">r_lim</span>
        <span class="k">elif</span> <span class="n">r_max</span> <span class="o">&gt;</span> <span class="n">r_lim</span> <span class="ow">or</span> <span class="n">r_max</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`r_max` must be in range of 0 &lt; r_max &lt;= </span><span class="si">{</span><span class="n">r_lim</span><span class="si">}</span><span class="s2"> with this image.&quot;</span>
            <span class="p">)</span>
        
        <span class="c1"># make radially separated labels</span>
        <span class="n">r_rel</span> <span class="o">=</span> <span class="n">r</span><span class="o">/</span><span class="n">r_max</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbin</span> <span class="o">*</span> <span class="n">r_rel</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">r_rel</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="n">PropArray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">c_axes</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">max</span><span class="p">()),)),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">c_axes</span> <span class="o">+</span> <span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> 
            <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> 
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> 
            <span class="n">propname</span><span class="o">=</span><span class="s2">&quot;radial_profile&quot;</span>
        <span class="p">)</span>
        <span class="n">radial_func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">cupy_dispatcher</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">c_axes</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">radial_func</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.gaussfit"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.gaussfit">[docs]</a>    <span class="nd">@dims_to_spatial_axes</span>
    <span class="k">def</span> <span class="nf">gaussfit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">16</span><span class="p">,</span>
        <span class="n">p0</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Powell&quot;</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="s2">&quot;yx&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the image to 2-D Gaussian background.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale : float, default is 1/16.</span>
<span class="sd">            Scale of rough image (to speed up fitting).</span>
<span class="sd">        p0 : sequence of float, optional</span>
<span class="sd">            Initial parameters.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Fitting method. See `scipy.optimize.minimize`.</span>
<span class="sd">        mask : np.ndarray, optional,</span>
<span class="sd">            If given, ignore the True region from fitting.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Fit image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="n">ndim</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">.bases</span> <span class="kn">import</span> <span class="n">MetaArray</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">MetaArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="n">ndim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="n">c_axes</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">c_axes</span><span class="p">,</span> <span class="n">israw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">fit</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">gaussfit</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
                <span class="n">params</span><span class="p">[</span><span class="n">sl</span><span class="p">[:</span><span class="o">-</span><span class="n">ndim</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;GaussianParameters&quot;</span><span class="p">]</span>
                <span class="n">out</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">value</span>
            <span class="n">out</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">out</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;GaussianParameters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span>
            <span class="k">return</span> <span class="n">out</span>
        
        <span class="n">rough</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">asarray</span> <span class="k">as</span> <span class="n">ip_asarray</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">ip_asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">gaussian</span> <span class="o">=</span> <span class="n">GaussianBackground</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
        <span class="n">gaussian</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">rough</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">gaussian</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">gaussian</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;GaussianParameters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaussian</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fit</span></div>
    
<div class="viewcode-block" id="ImgArray.gauss_correction"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.gauss_correction">[docs]</a>    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">gauss_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">:</span> <span class="n">ImgArray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">16</span><span class="p">,</span> <span class="n">median_radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Correct unevenly distributed excitation light using Gaussian fitting. This method subtracts</span>
<span class="sd">        background intensity at the same time. If input image is uint, then output value under 0 will</span>
<span class="sd">        replaced with 0. If you want to quantify background, it is necessary to first convert input</span>
<span class="sd">        image to float image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ref : ImgArray, default is `self`.</span>
<span class="sd">            Reference image to estimate background.</span>
<span class="sd">        scale : float, default is 1/16.</span>
<span class="sd">            Scale of rough image (to speed up fitting).</span>
<span class="sd">        median_radius : float, default is 15.</span>
<span class="sd">            Radius of median prefilter&#39;s kernel. If smaller than 1, prefiltering will be skipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Corrected and background subtracted image.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        1. When input image has &quot;ptcyx&quot;-axes, and you want to estimate the background intensity</span>
<span class="sd">        for each channel by averaging all the positions and times.</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; img_cor = img.gauss_correction(ref=img.proj(&quot;pt&quot;))</span>
<span class="sd">        </span>
<span class="sd">        2. When input image has &quot;ptcyx&quot;-axes, and you want to estimate the background intensity</span>
<span class="sd">        for each channel and time point by averaging all the positions.</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; img_cor = img.gauss_correction(ref=img.proj(&quot;p&quot;))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`ref` must be None or ImgArray, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">self_loop_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">ref_loop_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="s2">&quot;yx&quot;</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sl0</span><span class="p">,</span> <span class="n">ref_</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">ref_loop_axes</span><span class="p">,</span> <span class="n">israw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">ref_</span><span class="p">:</span> <span class="n">ImgArray</span>
            <span class="k">if</span> <span class="n">median_radius</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ref_</span> <span class="o">=</span> <span class="n">ref_</span><span class="o">.</span><span class="n">median_filter</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">median_radius</span><span class="p">)</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">ref_</span><span class="o">.</span><span class="n">gaussfit</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">self_loop_axes</span><span class="p">,</span> <span class="n">israw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">sl</span><span class="p">][</span><span class="n">sl0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">sl0</span><span class="p">]</span> <span class="o">/</span> <span class="n">fit</span> <span class="o">*</span> <span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="ImgArray.hessian_eigval"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.hessian_eigval">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="k">def</span> <span class="nf">hessian_eigval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate Hessian&#39;s eigenvalues for each image. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {sigma}</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Array of eigenvalues. The axis ``&quot;base&quot;`` denotes the index of eigenvalues.</span>
<span class="sd">            l=0 means the smallest eigenvalue.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Extract filament</span>
<span class="sd">            &gt;&gt;&gt; eig = -img.hessian_eigval()[ip.slicer.base[0]]</span>
<span class="sd">            &gt;&gt;&gt; eig[eig&lt;0] = 0</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="n">pxsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])</span>
        
        <span class="n">eigval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_linalg</span><span class="o">.</span><span class="n">hessian_eigval</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">new_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">pxsize</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="n">eigval</span><span class="p">:</span> <span class="n">ImgArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">eigval</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;base&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        <span class="n">eigval</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="n">new_axes</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">eigval</span></div>
    
<div class="viewcode-block" id="ImgArray.hessian_eig"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.hessian_eig">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="k">def</span> <span class="nf">hessian_eig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ImgArray</span><span class="p">,</span> <span class="n">ImgArray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate Hessian&#39;s eigenvalues and eigenvectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {sigma}{dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray and ImgArray</span>
<span class="sd">            Arrays of eigenvalues and eigenvectors. The axis ``&quot;base&quot;`` denotes the index of </span>
<span class="sd">            eigenvalues. l=0 means the smallest eigenvalue. ``&quot;dim&quot;`` denotes the index of</span>
<span class="sd">            spatial dimensions. For 3D image, dim=0 means z-element of an eigenvector.</span>
<span class="sd">        &quot;&quot;&quot;</span>                
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="n">pxsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])</span>
        
        <span class="n">eigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_linalg</span><span class="o">.</span><span class="n">hessian_eigh</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">new_axis</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">pxsize</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec</span> <span class="o">=</span> <span class="n">_linalg</span><span class="o">.</span><span class="n">eigs_post_process</span><span class="p">(</span><span class="n">eigs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec</span></div>
    
<div class="viewcode-block" id="ImgArray.structure_tensor_eigval"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.structure_tensor_eigval">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">structure_tensor_eigval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate structure tensor&#39;s eigenvalues and eigenvectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {sigma}</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Array of eigenvalues. The axis ``&quot;l&quot;`` denotes the index of eigenvalues.</span>
<span class="sd">            l=0 means the smallest eigenvalue.</span>
<span class="sd">        &quot;&quot;&quot;</span>          
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="n">pxsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])</span>
        
        <span class="n">eigval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_linalg</span><span class="o">.</span><span class="n">structure_tensor_eigval</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">new_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">pxsize</span><span class="p">),</span>
        <span class="p">)</span>
        
        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;base&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        <span class="n">eigval</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="n">new_axes</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">eigval</span></div>
    
<div class="viewcode-block" id="ImgArray.structure_tensor_eig"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.structure_tensor_eig">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">structure_tensor_eig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ImgArray</span><span class="p">,</span> <span class="n">ImgArray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate structure tensor&#39;s eigenvalues and eigenvectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {sigma}</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray and ImgArray</span>
<span class="sd">            Arrays of eigenvalues and eigenvectors. The axis ``&quot;l&quot;`` denotes the index of </span>
<span class="sd">            eigenvalues. l=0 means the smallest eigenvalue. ``&quot;r&quot;`` denotes the index of</span>
<span class="sd">            spatial dimensions. For 3D image, r=0 means z-element of an eigenvector.</span>
<span class="sd">        &quot;&quot;&quot;</span>                
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="n">pxsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])</span>
        
        <span class="n">eigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_linalg</span><span class="o">.</span><span class="n">structure_tensor_eigh</span><span class="p">,</span>
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">new_axis</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">pxsize</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec</span> <span class="o">=</span> <span class="n">_linalg</span><span class="o">.</span><span class="n">eigs_post_process</span><span class="p">(</span><span class="n">eigs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec</span></div>
    
<div class="viewcode-block" id="ImgArray.edge_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.edge_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">edge_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sobel&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sobel filter. This filter is useful for edge detection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, {&quot;sobel&quot;, &quot;farid&quot;, &quot;scharr&quot;, &quot;prewitt&quot;}, default is &quot;sobel&quot;</span>
<span class="sd">            Edge operator name.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># Get operator</span>
        <span class="n">method_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sobel&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">sobel</span><span class="p">,</span>
                       <span class="s2">&quot;farid&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">farid</span><span class="p">,</span>
                       <span class="s2">&quot;scharr&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">scharr</span><span class="p">,</span>
                       <span class="s2">&quot;prewitt&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">prewitt</span><span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">method_dict</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`method` must be &#39;sobel&#39;, &#39;farid&#39; &#39;scharr&#39;, or &#39;prewitt&#39;.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="ImgArray.lowpass_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.lowpass_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">lowpass_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Butterworth low-pass filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cutoff : float or array-like, default is 0.2</span>
<span class="sd">            Cutoff frequency.</span>
<span class="sd">        order : float, default is 2</span>
<span class="sd">            Steepness of cutoff.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image</span>
<span class="sd">        &quot;&quot;&quot;</span>         
        <span class="kn">from</span> <span class="nn">._utils._skimage</span> <span class="kn">import</span> <span class="n">_get_ND_butterworth_filter</span>
        <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">ndims</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ndims</span><span class="p">)</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cutoff</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">spatial_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">spatial_axes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axisof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_ND_butterworth_filter</span><span class="p">(</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">add_axes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfftn</span><span class="p">(</span>
            <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">*</span> <span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">spatial_axes</span><span class="p">),</span> 
            <span class="n">s</span><span class="o">=</span><span class="n">spatial_shape</span><span class="p">,</span> 
            <span class="n">axes</span><span class="o">=</span><span class="n">spatial_axes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.lowpass_conv_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.lowpass_conv_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">lowpass_conv_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Butterworth low-pass filter in real space. Butterworth kernel is created first using inverse</span>
<span class="sd">        Fourier transform of weight function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cutoff : float or array-like, default is 0.2</span>
<span class="sd">            Cutoff frequency.</span>
<span class="sd">        order : float, default is 2</span>
<span class="sd">            Steepness of cutoff.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image</span>
<span class="sd">        &quot;&quot;&quot;</span>       
        <span class="kn">from</span> <span class="nn">._utils._skimage</span> <span class="kn">import</span> <span class="n">_get_ND_butterworth_filter</span>
        <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">ndims</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ndims</span><span class="p">)</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cutoff</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">spatial_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_ND_butterworth_filter</span><span class="p">(</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">ker_all</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfftn</span><span class="p">(</span><span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weight</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="n">spatial_shape</span><span class="p">))</span>
        <span class="n">ker_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">ker_all</span><span class="p">)</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">c</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
            <span class="n">sl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">s</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="n">radius</span><span class="p">,</span> <span class="n">s</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="n">radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ker</span> <span class="o">=</span> <span class="n">ker_all</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">ker</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.tiled_lowpass_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.tiled_lowpass_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">tiled_lowpass_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> 
        <span class="n">overlap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tile-by-tile Butterworth low-pass filter. This method is an approximation of the standard</span>
<span class="sd">        low-pass filter, which would be useful when the image is large.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cutoff : float or array-like, default is 0.2</span>
<span class="sd">            Cutoff frequency.</span>
<span class="sd">        chunks : str or sequence of int</span>
<span class="sd">            Chunk size of each lowpass filter task.</span>
<span class="sd">        order : float, default is 2</span>
<span class="sd">            Steepness of cutoff.</span>
<span class="sd">        overlap : int, default is 16</span>
<span class="sd">            Overlapping pixels at the edges of tiles.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="n">dims</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;batch processing not implemented yet.&quot;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">._utils._skimage</span> <span class="kn">import</span> <span class="n">_get_ND_butterworth_filter</span>
        <span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">da</span>

        <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">ndims</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ndims</span><span class="p">)</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cutoff</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        
        <span class="n">depth</span> <span class="o">=</span> <span class="n">switch_slice</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_ND_butterworth_filter</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">ft</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">*</span> <span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">ift</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfftn</span><span class="p">(</span><span class="n">ft</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">ift</span><span class="p">)</span>
        
        <span class="nb">input</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.highpass_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.highpass_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">highpass_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Butterworth high-pass filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cutoff : float or array-like, default is 0.2</span>
<span class="sd">            Cutoff frequency.</span>
<span class="sd">        order : float, default is 2</span>
<span class="sd">            Steepness of cutoff.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image</span>
<span class="sd">        &quot;&quot;&quot;</span>         
        <span class="kn">from</span> <span class="nn">._utils._skimage</span> <span class="kn">import</span> <span class="n">_get_ND_butterworth_filter</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="n">spatial_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">spatial_axes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axisof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_ND_butterworth_filter</span><span class="p">(</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">add_axes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfftn</span><span class="p">(</span><span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="o">*</span><span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">spatial_axes</span><span class="p">),</span> 
                            <span class="n">s</span><span class="o">=</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">spatial_axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="ImgArray.convolve"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.convolve">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span> 
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        General linear convolution by running kernel filtering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kernel : array-like</span>
<span class="sd">            Convolution kernel.</span>
<span class="sd">        {mode}{cval}{dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Convolved image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">convolve</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">kernel</span><span class="p">,),</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">)</span>
        <span class="p">)</span></div>
        
<div class="viewcode-block" id="ImgArray.erosion"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.erosion">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">erosion</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Morphological erosion. </span>
<span class="sd">        </span>
<span class="sd">        If input is binary image, the running function will automatically switched to</span>
<span class="sd">        ``binary_erosion`` to speed up calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}{mode}{cval}{dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">disk</span> <span class="o">=</span> <span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">_filters</span><span class="o">.</span><span class="n">binary_erosion</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">disk</span><span class="p">,</span> <span class="n">border_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">_filters</span><span class="o">.</span><span class="n">erosion</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">footprint</span><span class="o">=</span><span class="n">disk</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.dilation"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.dilation">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">dilation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Morphological dilation. If input is binary image, the running function will automatically switched to</span>
<span class="sd">        ``binary_dilation`` to speed up calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}{mode}{cval}{dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">disk</span> <span class="o">=</span> <span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">_filters</span><span class="o">.</span><span class="n">binary_dilation</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">disk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">_filters</span><span class="o">.</span><span class="n">dilation</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">footprint</span><span class="o">=</span><span class="n">disk</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.opening"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.opening">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">opening</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Morphological opening. If input is binary image, the running function will automatically switched to</span>
<span class="sd">        ``binary_opening`` to speed up calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}{mode}{cval}{dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">disk</span> <span class="o">=</span> <span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">_filters</span><span class="o">.</span><span class="n">binary_opening</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">disk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">_filters</span><span class="o">.</span><span class="n">opening</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">footprint</span><span class="o">=</span><span class="n">disk</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.closing"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.closing">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">closing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Morphological closing. </span>
<span class="sd">        </span>
<span class="sd">        If input is binary image, the running function will automatically switched to</span>
<span class="sd">        ``binary_closing`` to speed up calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}{dims}{mode}{cval}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">disk</span> <span class="o">=</span> <span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">_filters</span><span class="o">.</span><span class="n">binary_closing</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">disk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">_filters</span><span class="o">.</span><span class="n">closing</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">footprint</span><span class="o">=</span><span class="n">disk</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.tophat"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.tophat">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">tophat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tophat morphological image processing. This is useful for background subtraction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}{mode}{cval}{dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        
        <span class="n">disk</span> <span class="o">=</span> <span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">white_tophat</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">footprint</span><span class="o">=</span><span class="n">disk</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">)</span>
        <span class="p">)</span></div>
    
    
<div class="viewcode-block" id="ImgArray.smooth_mask"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.smooth_mask">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span><span class="p">(</span><span class="n">only_binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">smooth_mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">dilate_radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">mask_light</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothen binary mask image at its edges. This is useful to make a &quot;soft mask&quot;.</span>
<span class="sd">        </span>
<span class="sd">        This method applies erosion/dilation to a binary image and then smooth its edges by Gaussian.</span>
<span class="sd">        The total value is always larger after Gaussian smoothing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : float, default is 2.0</span>
<span class="sd">            Standard deviation of Gaussian blur.</span>
<span class="sd">        dilate_radius : float, default is 2.0</span>
<span class="sd">            Radius in pixel that will be used to dilate mask before smoothing.</span>
<span class="sd">        mask_light : bool, default is False</span>
<span class="sd">            If true, mask array is considered to mask other image at its True values. Otherwise mask array </span>
<span class="sd">            plays more like a weight array, that is, False region will be zero.</span>
<span class="sd">        {dims}</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Smoothened mask image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask_light</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span>
        
        <span class="k">if</span> <span class="n">dilate_radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">erosion</span><span class="p">(</span><span class="n">dilate_radius</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dilate_radius</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">(</span><span class="o">-</span><span class="n">dilate_radius</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">sigma</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_map</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">blurred_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sigma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">blurred_mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sigma must be non-negative.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask_light</span><span class="p">:</span>
            <span class="n">blurred_mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">blurred_mask</span>
        <span class="k">return</span> <span class="n">blurred_mask</span></div>
    
<div class="viewcode-block" id="ImgArray.mean_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.mean_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">mean_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mean filter. Kernel is filled with same values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}{mode}{cval}{dims}{update}</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">disk</span> <span class="o">=</span> <span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">mean_filter</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">disk</span><span class="p">,),</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">),</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.std_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.std_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">std_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standard deviation filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}{mode}{cval}{dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">disk</span> <span class="o">=</span> <span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">std_filter</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">disk</span><span class="p">,),</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">),</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.coef_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.coef_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">coef_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Coefficient of variance filter. </span>
<span class="sd">        </span>
<span class="sd">        For kernel area X, :math:`\frac{\sqrt{V[X]}}{E[X]}` is calculated. This filter</span>
<span class="sd">        is useful for feature extraction from images with uneven background intensity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}{mode}{cval}{dims}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">disk</span> <span class="o">=</span> <span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">coef_filter</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">disk</span><span class="p">,),</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">),</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.median_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.median_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">median_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Running multi-dimensional median filter. </span>
<span class="sd">        </span>
<span class="sd">        This filter is useful for deleting outliers generated by noise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}{mode}{cval}{dims}{update}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>     
        <span class="n">disk</span> <span class="o">=</span> <span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">median_filter</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">footprint</span><span class="o">=</span><span class="n">disk</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">),</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.diameter_opening"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.diameter_opening">[docs]</a>    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">diameter_opening</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diameter</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                         <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">diameter_opening</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">diameter_opening</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">diameter_threshold</span><span class="o">=</span><span class="n">diameter</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
        <span class="p">)</span></div>
        
<div class="viewcode-block" id="ImgArray.diameter_closing"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.diameter_closing">[docs]</a>    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">diameter_closing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diameter</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">diameter_closing</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">diameter_closing</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">diameter_threshold</span><span class="o">=</span><span class="n">diameter</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.area_opening"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.area_opening">[docs]</a>    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">area_opening</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">remove_small_holes</span><span class="p">,</span> <span class="n">area_opening</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
                <span class="n">remove_small_holes</span><span class="p">,</span>
                <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">area_threshold</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
                <span class="n">area_opening</span><span class="p">,</span> 
                <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">area_threshold</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="p">)</span></div>
        
<div class="viewcode-block" id="ImgArray.area_closing"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.area_closing">[docs]</a>    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">area_closing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">remove_small_holes</span><span class="p">,</span> <span class="n">area_closing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
                <span class="n">remove_small_holes</span><span class="p">,</span>
                <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">area_threshold</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
                <span class="n">area_closing</span><span class="p">,</span> 
                <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">area_threshold</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.entropy_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.entropy_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">entropy_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Running entropy filter. This filter is useful for detecting change in background distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}{dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">disk</span> <span class="o">=</span> <span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_uint8</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span><span class="n">skfil</span><span class="o">.</span><span class="n">rank</span><span class="o">.</span><span class="n">entropy</span><span class="p">,</span> 
                               <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
                               <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">footprint</span><span class="o">=</span><span class="n">disk</span><span class="p">)</span>
                               <span class="p">)</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="ImgArray.enhance_contrast"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.enhance_contrast">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">enhance_contrast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span><span class="n">nDFloat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enhance contrast filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}{dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Contrast enhanced image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">disk</span> <span class="o">=</span> <span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[:]</span> <span class="o">/=</span> <span class="n">amp</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span><span class="n">skfil</span><span class="o">.</span><span class="n">rank</span><span class="o">.</span><span class="n">enhance_contrast</span><span class="p">,</span> 
                                  <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
                                  <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                  <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">disk</span><span class="p">,)</span>
                                  <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">amp</span>
        
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.laplacian_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.laplacian_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">laplacian_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Edge detection using Laplacian filter. Kernel is made by `skimage`&#39;s function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        radius : int, default is 1</span>
<span class="sd">            Radius of kernel. Shape of kernel will be (2*radius+1, 2*radius+1).</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">laplace_op</span> <span class="o">=</span> <span class="n">skres</span><span class="o">.</span><span class="n">uft</span><span class="o">.</span><span class="n">laplacian</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="o">+</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">convolve</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">laplace_op</span><span class="p">,),</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.kalman_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.kalman_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">kalman_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">noise_var</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">along</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;t&quot;</span><span class="p">,</span> 
                      <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman filter for image smoothing. This function is same as &quot;Kalman Stack Filter&quot; in ImageJ but support</span>
<span class="sd">        batch processing. This filter is useful for preprocessing of particle tracking.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gain : float, default is 0.8</span>
<span class="sd">            Filter gain.</span>
<span class="sd">        noise_var : float, default is 0.05</span>
<span class="sd">            Initial estimate of noise variance.</span>
<span class="sd">        along : str, default is &quot;t&quot;</span>
<span class="sd">            Which axis will be the time axis.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">t_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisof</span><span class="p">(</span><span class="n">along</span><span class="p">)</span>
        <span class="n">min_a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axisof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t_axis</span> <span class="o">&gt;</span> <span class="n">min_a</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_axis</span><span class="p">,</span> <span class="n">min_a</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">kalman_filter</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">([</span><span class="n">along</span><span class="p">]</span> <span class="o">+</span> <span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="n">noise_var</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">t_axis</span> <span class="o">&gt;</span> <span class="n">min_a</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">min_a</span><span class="p">,</span> <span class="n">t_axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.focus_map"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.focus_map">[docs]</a>    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">focus_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PropArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute focus map using variance of Laplacian method. yx-plane with higher variance is likely a</span>
<span class="sd">        focal plane because sharper image causes higher value of Laplacian on the edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        radius : int, default is 1</span>
<span class="sd">            Radius of Laplacian filter&#39;s kernel.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PropArray</span>
<span class="sd">            Array of variance of Laplacian</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Get the focus plane from a 3D image.</span>
<span class="sd">            &gt;&gt;&gt; score = img.focus_map()</span>
<span class="sd">            &gt;&gt;&gt; score.plot()               # plot the variation of laplacian focus</span>
<span class="sd">            &gt;&gt;&gt; z_focus = np.argmax(score) # determine the focus plane</span>
<span class="sd">            &gt;&gt;&gt; img[z_focus]               # get the focus plane</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">laplace_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">laplacian_filter</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">laplace_img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">PropArray</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> 
                        <span class="n">axes</span><span class="o">=</span><span class="n">c_axes</span><span class="p">,</span> <span class="n">propname</span><span class="o">=</span><span class="s2">&quot;variance_of_laplacian&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.unmix"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.unmix">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">unmix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">bg</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">along</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unmix fluorescence leakage between channels in a linear way. For example, a blue/green image,</span>
<span class="sd">        fluorescent leakage can be written as following equation:</span>
<span class="sd">        </span>
<span class="sd">            :math:`\left\{\begin{array}{ll} B_{obs} = B_{real} + a \cdot G_{real} &amp; \\G_{obs} = b \cdot B_{real} + G_{real} &amp; \end{array} \right.`</span>
<span class="sd">            </span>
<span class="sd">        where &quot;obs&quot; means observed intensities, &quot;real&quot; means the real intensity. In this linear case, </span>
<span class="sd">        leakage matrix:</span>
<span class="sd">        </span>
<span class="sd">            :math:`M = \begin{bmatrix} 1 &amp; a \\b &amp; 1 \end{bmatrix} \\`</span>
<span class="sd">                                    </span>
<span class="sd">            :math:`V_{obs} = M \cdot V_{real}`</span>
<span class="sd">            </span>
<span class="sd">        must be predefined. If M is given, then real intensities can be restored by:</span>
<span class="sd">            </span>
<span class="sd">            :math:`V_{real} = M^{-1} \cdot V_{obs}`</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : array-like</span>
<span class="sd">            Leakage matrix. The (i, j) component of the matrix is the leakage from i-th channel to</span>
<span class="sd">            j-th channel.</span>
<span class="sd">        bg : array-like, optional</span>
<span class="sd">            Vector of background intensities for each channel. If not given, it is assumed to be the</span>
<span class="sd">            minimum value of each channel.</span>
<span class="sd">        along : str, default is &quot;c&quot;</span>
<span class="sd">            The axis of channel.</span>
<span class="sd">        {update}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Unmixed image.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Complement the channel-0 to channel-1 leakage.</span>
<span class="sd">            &gt;&gt;&gt; mtx = [[1.0, 0.4],</span>
<span class="sd">            &gt;&gt;&gt;        [0.0, 1.0]]</span>
<span class="sd">            &gt;&gt;&gt; bg = [1500, 1200]</span>
<span class="sd">            &gt;&gt;&gt; unmixed_img = img.unmix(mtx, bg)</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">n_chn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">along</span><span class="p">)</span>
        <span class="n">c_ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisof</span><span class="p">(</span><span class="n">along</span><span class="p">)</span>
        
        <span class="c1"># check matrix and bg</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_chn</span><span class="p">,</span> <span class="n">n_chn</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`map_matrix` must have shape </span><span class="si">{</span><span class="p">(</span><span class="n">n_chn</span><span class="p">,</span> <span class="n">n_chn</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_chn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">bg</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">n_chn</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`bg` must have length </span><span class="si">{</span><span class="n">n_chn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># move channel axis to the last</span>
        <span class="n">input_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">c_ax</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># multiply inverse matrix</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_</span> <span class="o">-</span> <span class="n">bg</span><span class="p">)</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span> <span class="o">+</span> <span class="n">bg</span>
        <span class="c1"># restore the axes order</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c_ax</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span></div>
        
    
<div class="viewcode-block" id="ImgArray.fill_hole"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.fill_hole">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">fill_hole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thr</span><span class="p">:</span> <span class="nb">float</span><span class="o">|</span><span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;otsu&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filling holes. See skimage&#39;s documents </span>
<span class="sd">        `here &lt;https://scikit-image.org/docs/stable/auto_examples/features_detection/plot_holes_and_peaks.html&gt;`_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        thr : scalar or str, optional</span>
<span class="sd">            Threshold (value or method) to apply if image is not binary.</span>
<span class="sd">        {dims}{update}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Hole-filled image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">thr</span><span class="o">=</span><span class="n">thr</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
                    
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">fill_hole</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">mask</span><span class="p">,),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ImgArray.gaussian_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.gaussian_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">gaussian_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run Gaussian filter (Gaussian blur).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {sigma}{dims}{update}</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">sigma</span><span class="p">,),</span> 
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ImgArray.dog_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.dog_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">dog_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high_sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run Difference of Gaussian filter. This function does not support `update`</span>
<span class="sd">        argument because intensity can be negative.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_sigma : scalar or array of scalars, default is 1.</span>
<span class="sd">            lower standard deviation(s) of Gaussian.</span>
<span class="sd">        high_sigma : scalar or array of scalars, default is x1.6 of low_sigma.</span>
<span class="sd">            higher standard deviation(s) of Gaussian.</span>
<span class="sd">        {dims}</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        
        <span class="n">low_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">check_nd</span><span class="p">(</span><span class="n">low_sigma</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)))</span>
        <span class="n">high_sigma</span> <span class="o">=</span> <span class="n">low_sigma</span> <span class="o">*</span> <span class="mf">1.6</span> <span class="k">if</span> <span class="n">high_sigma</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">high_sigma</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">dog_filter</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">low_sigma</span><span class="p">,</span> <span class="n">high_sigma</span><span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.doh_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.doh_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">doh_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determinant of Hessian filter. This function does not support `update`</span>
<span class="sd">        argument because output has total different scale of intensity. </span>
<span class="sd">        </span>
<span class="sd">            .. warning::</span>
<span class="sd">                Because in most cases we want to find only bright dots, eigenvalues larger </span>
<span class="sd">                than 0 is ignored before computing determinant.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {sigma}{dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="n">pxsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">doh_filter</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">pxsize</span><span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.log_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.log_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">log_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Laplacian of Gaussian filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {sigma}{dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">gaussian_laplace</span><span class="p">,</span>
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">sigma</span><span class="p">,)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.rolling_ball"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.rolling_ball">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">rolling_ball</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">prefilter</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">return_bg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract Background using rolling-ball algorithm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {radius}</span>
<span class="sd">        prefilter : &quot;mean&quot;, &quot;median&quot; or &quot;none&quot;</span>
<span class="sd">            If apply 3x3 averaging before creating background.</span>
<span class="sd">        {dims}{update}</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Background subtracted image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prefilter</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
                <span class="n">_filters</span><span class="o">.</span><span class="n">mean_filter</span><span class="p">,</span> 
                <span class="n">c_axes</span><span class="o">=</span><span class="n">c_axes</span><span class="p">,</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">selem</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)))</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">prefilter</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
                <span class="n">_filters</span><span class="o">.</span><span class="n">median_filter</span><span class="p">,</span> 
                <span class="n">c_axes</span><span class="o">=</span><span class="n">c_axes</span><span class="p">,</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">footprint</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)))</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">prefilter</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`prefilter` must be &#39;mean&#39;, &#39;median&#39; or &#39;none&#39;.&quot;</span><span class="p">)</span>
        <span class="n">filt</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        <span class="n">back</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">skres</span><span class="o">.</span><span class="n">rolling_ball</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">c_axes</span><span class="p">,</span> 
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_bg</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">back</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">back</span></div>
    
<div class="viewcode-block" id="ImgArray.rof_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.rof_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">rof_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lmd</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rudin-Osher-Fatemi&#39;s total variation denoising.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lmd : float, default is 0.05</span>
<span class="sd">            Constant value in total variation.</span>
<span class="sd">        tol : float, default is 1e-4</span>
<span class="sd">            Iteration stops when gain is under this value.</span>
<span class="sd">        max_iter : int, default is 50</span>
<span class="sd">            Maximum number of iterations.</span>
<span class="sd">        {dims}{update}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Filtered image</span>
<span class="sd">        &quot;&quot;&quot;</span>     
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">skres</span><span class="o">.</span><span class="n">_denoise</span><span class="o">.</span><span class="n">_denoise_tv_chambolle_nd</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="n">lmd</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">)</span>
        <span class="p">)</span></div>
        
<div class="viewcode-block" id="ImgArray.wavelet_denoising"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.wavelet_denoising">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">wavelet_denoising</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">noise_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">wavelet</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;db1&quot;</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;soft&quot;</span><span class="p">,</span> <span class="s2">&quot;hard&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;soft&quot;</span><span class="p">,</span> 
        <span class="n">wavelet_levels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;BayesShrink&quot;</span><span class="p">,</span> <span class="s2">&quot;VisuShrink&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;BayesShrink&quot;</span><span class="p">,</span>
        <span class="n">max_shifts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">shift_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wavelet denoising. Because it is not shift invariant, ``cycle_spin`` is called inside the </span>
<span class="sd">        function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        noise_sigma : float, optional</span>
<span class="sd">            Standard deviation of noise, if known.</span>
<span class="sd">        wavelet : str, default is &quot;db1&quot;</span>
<span class="sd">            Any options of `pywt.wavelist`.</span>
<span class="sd">        mode : {&quot;soft&quot;, &quot;hard&quot;}, default is &quot;soft&quot;</span>
<span class="sd">            Type of denoising.</span>
<span class="sd">        wavelet_levels : int, optional</span>
<span class="sd">            The number of wavelet decomposition levels to use.</span>
<span class="sd">        method : {&quot;BayesShrink&quot;, &quot;VisuShrink&quot;}, default is &quot;BayesShrink&quot;</span>
<span class="sd">            Thresholding method to be used</span>
<span class="sd">        max_shifts : int or tuple, default is 0</span>
<span class="sd">            Shifts in range(0, max_shifts+1) will be used.</span>
<span class="sd">        shift_steps : int or tuple, default is 1</span>
<span class="sd">            Step size of shifts.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Denoised image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">func_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">noise_sigma</span><span class="p">,</span> 
            <span class="n">wavelet</span><span class="o">=</span><span class="n">wavelet</span><span class="p">,</span> 
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> 
            <span class="n">wavelet_levels</span><span class="o">=</span><span class="n">wavelet_levels</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">skres</span><span class="o">.</span><span class="n">cycle_spin</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">skres</span><span class="o">.</span><span class="n">denoise_wavelet</span><span class="p">,),</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">func_kw</span><span class="o">=</span><span class="n">func_kw</span><span class="p">,</span> <span class="n">max_shifts</span><span class="o">=</span><span class="n">max_shifts</span><span class="p">,</span> <span class="n">shift_steps</span><span class="o">=</span><span class="n">shift_steps</span><span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.split_pixel_unit"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.split_pixel_unit">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="k">def</span> <span class="nf">split_pixel_unit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">angle_order</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">newaxis</span><span class="p">:</span> <span class="n">AxisLike</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split a (2N, 2M)-image into four (N, M)-images for each other pixels.</span>
<span class="sd">        </span>
<span class="sd">        Generally, image acquisition with a polarization camera will output </span>
<span class="sd">        :math:`(2N, 2M)`-image with :math:`N \times M` pixel units:</span>
<span class="sd">        </span>
<span class="sd">        +-+-+-+-+-+-+</span>
<span class="sd">        |0|1|0|1|0|1|</span>
<span class="sd">        +-+-+-+-+-+-+</span>
<span class="sd">        |3|2|3|2|3|2|</span>
<span class="sd">        +-+-+-+-+-+-+</span>
<span class="sd">        |0|1|0|1|0|1|</span>
<span class="sd">        +-+-+-+-+-+-+</span>
<span class="sd">        |3|2|3|2|3|2|</span>
<span class="sd">        +-+-+-+-+-+-+</span>
<span class="sd">        </span>
<span class="sd">        This function generates images only consist of positions of [0], [1], </span>
<span class="sd">        [2] or [3]. Strictly, each image is acquired from different position </span>
<span class="sd">        (the pixel (i, j) in [0]-image and the pixel (i, j) in [1]-image are </span>
<span class="sd">        acquired from different positions). This function also complements for</span>
<span class="sd">        this difference by interpolation.</span>
<span class="sd">         </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : tuple, default is (0, 0)</span>
<span class="sd">            Coordinate that will be considered as the center of the returned </span>
<span class="sd">            image. Input (a, b) must satisfy 0 &lt; a &lt; 1 and 0 &lt; b &lt; 1. For example,</span>
<span class="sd">            center=(0, 0) means the most upper left pixel, and center=(0.5, 0.5)</span>
<span class="sd">            means the middle point of a pixel unit. `[[0, 1], [3, 2]]` becomes</span>
<span class="sd">            `[[(0, 0), (0, 1)], [(1, 0), (1, 1)]]`.</span>
<span class="sd">                    </span>
<span class="sd">        {order}</span>
<span class="sd">        angle_order : list of int, default is [2, 1, 0, 3]</span>
<span class="sd">            Specify which pixels correspond to which polarization angles. 0, 1, 2 </span>
<span class="sd">            and 3 corresponds to polarization of 0, 45, 90 and 135 degree</span>
<span class="sd">            respectively. This list will be directly passed to ``np.ndarray`` like</span>
<span class="sd">            ``arr[angle_order]`` to sort it. For example, if a pixel unit receives </span>
<span class="sd">            polarized light like below:</span>
<span class="sd">            </span>
<span class="sd">                .. code-block::</span>
<span class="sd">            </span>
<span class="sd">                    [0] [1]    [ 90] [ 45]    [|] [/]</span>
<span class="sd">                    [2] [3] -&gt; [135] [  0] or [\] [-]</span>
<span class="sd">                </span>
<span class="sd">            then ``angle_order`` should be [2, 1, 0, 3].</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Axis &quot;a&quot; is added in the first dimension. For example, If input is</span>
<span class="sd">            &quot;tyx&quot;-axes, then output will be &quot;atyx&quot;-axes.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Extract polarization in 0-, 45-, 90- and 135-degree directions from an </span>
<span class="sd">        image that is acquired from a polarization camera, and calculate total </span>
<span class="sd">        intensity of light by averaging.</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; img_pol = img.split_pixel_unit()</span>
<span class="sd">            &gt;&gt;&gt; img_total = img_pol.proj(axis=&quot;a&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">yc</span><span class="p">,</span> <span class="n">xc</span> <span class="o">=</span> <span class="n">center</span>
        <span class="k">if</span> <span class="n">angle_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">angle_order</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">y</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Image pixel sizes must be even numbers, got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="s1">&#39;yx&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">imgs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ImgArray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">get_formatter</span><span class="p">([</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]:</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="p">[(</span><span class="n">yc</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">xc</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">fmt</span><span class="p">[</span><span class="n">y</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">::</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span>
                    <span class="n">translation</span><span class="o">=</span><span class="n">dr</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="s2">&quot;yx&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">ImgArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">newaxis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">out</span><span class="o">.</span><span class="n">labels</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Output image labels are deleted because it is incompatible with &quot;</span>
                <span class="s2">&quot;split_pixel_unit&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">newaxis</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">angle_order</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
        
<div class="viewcode-block" id="ImgArray.stokes"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.stokes">[docs]</a>    <span class="k">def</span> <span class="nf">stokes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">along</span><span class="p">:</span> <span class="n">AxisLike</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate stocks images from an image stack with polarized images. </span>
<span class="sd">        </span>
<span class="sd">        Currently, Degree of Linear Polarization (DoLP) and Angle of </span>
<span class="sd">        Polarization (AoP) will be calculated. Those irregular values </span>
<span class="sd">        (np.nan, np.inf) will be replaced with 0. Be sure that to calculate</span>
<span class="sd">        DoPL correctly background subtraction must be applied beforehand because </span>
<span class="sd">        stokes parameter ``s0`` is affected by absolute intensities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        along : AxisLike, default is &quot;a&quot;</span>
<span class="sd">            To define which axis is polarization angle axis. Along this axis </span>
<span class="sd">            the angle of polarizer must be in order of 0, 45, 90, 135 degree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionaly with keys &quot;dolp&quot; and &quot;aop&quot;, which correspond to DoPL and </span>
<span class="sd">            AoP respectively.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate AoP image from the raw image and display them.</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; img_pol = img.split_polarization()</span>
<span class="sd">            &gt;&gt;&gt; dpol = img_pol.stokes()</span>
<span class="sd">            &gt;&gt;&gt; ip.gui.add(img_pol.proj())</span>
<span class="sd">            &gt;&gt;&gt; ip.gui.add(dpol.aop.rad2deg())</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://mavic.ne.jp/indutrialcamera-polarization-inline/</span>
<span class="sd">        - Yang, J., Qiu, S., Jin, W., Wang, X., &amp; Xue, F. (2020). Polarization imaging model considering the </span>
<span class="sd">          non-ideality of polarizers. Applied optics, 59(2), 306-314.</span>
<span class="sd">        - Feng, B., Guo, R., Zhang, F., Zhao, F., &amp; Dong, Y. (2021). Calculation and hue mapping of AoP in </span>
<span class="sd">          polarization imaging. May. https://doi.org/10.1117/12.2523643</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">along</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">img0</span><span class="p">,</span> <span class="n">img45</span><span class="p">,</span> <span class="n">img90</span><span class="p">,</span> <span class="n">img135</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">along</span><span class="p">)]</span>
        <span class="c1"># Stokes parameters</span>
        <span class="n">s0</span> <span class="o">=</span> <span class="p">(</span><span class="n">img0</span> <span class="o">+</span> <span class="n">img45</span> <span class="o">+</span> <span class="n">img90</span> <span class="o">+</span> <span class="n">img135</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">img0</span> <span class="o">-</span> <span class="n">img90</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">img45</span> <span class="o">-</span> <span class="n">img135</span>
        
        <span class="c1"># Degree of Linear Polarization (DoLP)</span>
        <span class="c1"># DoLP is defined as:</span>
        <span class="c1"># DoLP = sqrt(s1^2 + s2^2)/s0</span>
        <span class="n">s0</span><span class="p">[</span><span class="n">s0</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">dolp</span><span class="p">:</span> <span class="n">ImgArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">s2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">s0</span>
        <span class="n">dolp</span> <span class="o">=</span> <span class="n">dolp</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">dolp</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="n">new_axes</span><span class="p">)</span>
        <span class="n">dolp</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="c1"># Angle of Polarization (AoP)</span>
        <span class="c1"># AoP is usually calculated as psi = 1/2argtan(s1/s2), but this is wrong because </span>
        <span class="c1"># left side has range of [0, pi) while right side has range of [-pi/4, pi/4). The</span>
        <span class="c1"># correct formulation is:</span>
        <span class="c1">#       { 1/2argtan(s2/s1)          (s1&gt;0 and s2&gt;0)</span>
        <span class="c1"># AoP = { 1/2argtan(s2/s1) + pi/2   (s1&lt;0)</span>
        <span class="c1">#       { 1/2argtan(s2/s1) + pi     (s1&gt;0 and s2&lt;0)</span>
        <span class="c1"># But here, np.arctan2 can detect the signs of inputs s1 and s2, so that it returns </span>
        <span class="c1"># correct values.</span>
        <span class="n">aop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">aop</span><span class="p">:</span> <span class="n">PhaseArray</span> <span class="o">=</span> <span class="n">aop</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">PhaseArray</span><span class="p">)</span>
        <span class="n">aop</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="n">new_axes</span><span class="p">)</span>
        <span class="n">aop</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span>
        <span class="n">aop</span><span class="o">.</span><span class="n">border</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">aop</span><span class="o">.</span><span class="n">_fix_border</span><span class="p">()</span>
        <span class="n">aop</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dolp</span><span class="o">=</span><span class="n">dolp</span><span class="p">,</span> <span class="n">aop</span><span class="o">=</span><span class="n">aop</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.inpaint"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.inpaint">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">inpaint</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;biharmonic&quot;</span><span class="p">]</span> <span class="o">=</span><span class="s2">&quot;biharmonic&quot;</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Image inpainting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : np.ndarray</span>
<span class="sd">            Mask image. The True region will be inpainted.</span>
<span class="sd">        method : &quot;mean&quot; or &quot;biharmonic&quot;, default is &quot;biharmonic&quot;</span>
<span class="sd">            Inpainting method.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Inpainted image of same data type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;biharmonic&quot;</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">skres</span><span class="o">.</span><span class="n">inpaint</span><span class="o">.</span><span class="n">inpaint_biharmonic</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">_misc</span><span class="o">.</span><span class="n">inpaint_mean</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">mask</span><span class="p">,),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ImgArray.peak_local_max"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.peak_local_max">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">peak_local_max</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">min_distance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
        <span class="n">topn</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">topn_per_label</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">exclude_border</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">use_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MarkerFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find local maxima. This algorithm corresponds to ImageJ&#39;s &#39;Find Maxima&#39; but is more flexible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_distance : float, default is 1.0</span>
<span class="sd">            Minimum distance allowed for each two peaks. This parameter is slightly</span>
<span class="sd">            different from that in ``skimage.feature.peak_local_max`` because here float</span>
<span class="sd">            input is allowed and every time footprint is calculated.</span>
<span class="sd">        percentile : float, optional</span>
<span class="sd">            Percentile to compute absolute threshold.</span>
<span class="sd">        topn : int, optional</span>
<span class="sd">            Maximum number of peaks **for each iteration**.</span>
<span class="sd">        topn_per_label : int, default is np.inf</span>
<span class="sd">            Maximum number of peaks per label.</span>
<span class="sd">        use_labels : bool, default is True</span>
<span class="sd">            If use self.labels when it exists.</span>
<span class="sd">        {dims}</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkerFrame</span>
<span class="sd">            DataFrame with columns same as axes of self. For example, if self.axes is &quot;tcyx&quot; then</span>
<span class="sd">            return value has &quot;t&quot;, &quot;c&quot;, &quot;y&quot; and &quot;x&quot; columns, and sub-frame at t=0, c=0 contains all</span>
<span class="sd">            the coordinates of peaks in the slice at t=0, c=0.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        
        <span class="c1"># separate spatial dimensions and others</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">dims_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">c_axes_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c_axes</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_border</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">exclude_border</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_distance</span><span class="p">)</span> <span class="k">if</span> <span class="n">exclude_border</span> <span class="k">else</span> <span class="kc">False</span>
        
        <span class="n">thr</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">percentile</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">percentile</span><span class="p">)</span>
        
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="kn">from</span> <span class="nn">impy.frame</span> <span class="kn">import</span> <span class="n">MarkerFrame</span>

        <span class="n">df_all</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">c_axes</span><span class="p">,</span> <span class="n">israw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">dims</span><span class="p">):</span>
            <span class="c1"># skfeat.peak_local_max overwrite something so we need to give copy of img.</span>
            <span class="k">if</span> <span class="n">use_labels</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="kc">None</span>
            
            <span class="n">indices</span> <span class="o">=</span> <span class="n">skfeat</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span>
                <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">img</span><span class="p">),</span>
                <span class="n">footprint</span><span class="o">=</span><span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">min_distance</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)),</span>
                <span class="n">threshold_abs</span><span class="o">=</span><span class="n">thr</span><span class="p">,</span>
                <span class="n">num_peaks</span><span class="o">=</span><span class="n">topn</span><span class="p">,</span>
                <span class="n">num_peaks_per_label</span><span class="o">=</span><span class="n">topn_per_label</span><span class="p">,</span>
                <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
                <span class="n">exclude_border</span><span class="o">=</span><span class="n">exclude_border</span>
            <span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">dims_list</span><span class="p">)</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">c_axes_list</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl</span>
            <span class="n">df_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            
        <span class="n">out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">df_all</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">MarkerFrame</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.corner_harris"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.corner_harris">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">corner_harris</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate Harris response image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {sigma}</span>
<span class="sd">        k : float, optional</span>
<span class="sd">            Sensitivity factor to separate corners from edges, typically in range [0, 0.2].</span>
<span class="sd">            Small values of k result in detection of sharp corners.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Harris response</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">skfeat</span><span class="o">.</span><span class="n">corner_harris</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.voronoi"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.voronoi">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">voronoi</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">Coords</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">inf</span><span class="p">:</span> <span class="n">nDInt</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Voronoi segmentation of an image. </span>
<span class="sd">        </span>
<span class="sd">        Image region labeled with $i$ means that all the points in the region are</span>
<span class="sd">        closer to the $i$-th point than any other points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : MarkerFrame or (N, 2) array-like</span>
<span class="sd">            Coordinates of points.</span>
<span class="sd">        inf : int, array of int, optional</span>
<span class="sd">            Distance to infinity points. If not provided, infinity points are </span>
<span class="sd">            placed at 100 times further positions relative to the image shape.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Label</span>
<span class="sd">            Segmentation labels of image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Voronoi</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">_check_coordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        
        <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">inf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">infy</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="n">infx</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">infy</span> <span class="o">=</span> <span class="n">infx</span> <span class="o">=</span> <span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">infy</span><span class="p">,</span> <span class="n">infx</span> <span class="o">=</span> <span class="n">inf</span>
        
        <span class="n">infpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="o">-</span><span class="n">infy</span><span class="p">,</span> <span class="o">-</span><span class="n">infx</span><span class="p">],</span>
             <span class="p">[</span><span class="o">-</span><span class="n">infy</span><span class="p">,</span> <span class="n">nx</span> <span class="o">+</span> <span class="n">infx</span><span class="p">],</span>
             <span class="p">[</span><span class="n">ny</span> <span class="o">+</span> <span class="n">infy</span><span class="p">,</span> <span class="o">-</span><span class="n">infx</span><span class="p">],</span>
             <span class="p">[</span><span class="n">ny</span> <span class="o">+</span> <span class="n">infy</span><span class="p">,</span> <span class="n">nx</span> <span class="o">+</span> <span class="n">infx</span><span class="p">]],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="n">labels</span> <span class="o">=</span> <span class="n">largest_zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">n_label</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">crds</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)):</span>
            <span class="n">input_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">crds</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">infpoints</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">vor</span> <span class="o">=</span> <span class="n">Voronoi</span><span class="p">(</span><span class="n">input_coords</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">vor</span><span class="o">.</span><span class="n">regions</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">r0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">r0</span> <span class="ow">in</span> <span class="n">r</span><span class="p">):</span>
                    <span class="n">poly</span> <span class="o">=</span> <span class="n">vor</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                    <span class="n">grids</span> <span class="o">=</span> <span class="n">skmes</span><span class="o">.</span><span class="n">grid_points_in_poly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">poly</span><span class="p">)</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">sl</span><span class="p">][</span><span class="n">grids</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_label</span>
                    <span class="n">n_label</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">Label</span><span class="p">(</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;-label&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="p">)</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span></div>
    
<div class="viewcode-block" id="ImgArray.flood"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.flood">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">flood</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">seeds</span><span class="p">:</span> <span class="n">Coords</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span>
        <span class="n">connectivity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flood filling with a list of seed points. By repeating skimage&#39;s ``flood`` function,</span>
<span class="sd">        this method can perform segmentation of an image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seeds : MarkerFrame or (N, D) array-like</span>
<span class="sd">            Seed points to start flood filling.</span>
<span class="sd">        {connectivity}</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Intensity deviation within this value will be filled.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Labeled image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">flood</span>
        <span class="n">seeds</span> <span class="o">=</span> <span class="n">_check_coordinates</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">largest_zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">n_label_next</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">crds</span> <span class="ow">in</span> <span class="n">seeds</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">crd</span> <span class="ow">in</span> <span class="n">crds</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">crd</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">crd</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">sl</span><span class="p">][</span><span class="n">crd</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">n_label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">sl</span><span class="p">][</span><span class="n">crd</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n_label</span> <span class="o">=</span> <span class="n">n_label_next</span>
                    <span class="n">n_label_next</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">fill_area</span> <span class="o">=</span> <span class="n">flood</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span> 
                    <span class="n">seed_point</span><span class="o">=</span><span class="n">crd</span><span class="p">,</span>
                    <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> 
                    <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
                <span class="p">)</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">sl</span><span class="p">][</span><span class="n">fill_area</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_label</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">Label</span><span class="p">(</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;-label&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="p">)</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ImgArray.find_sm"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.find_sm">[docs]</a>    <span class="nd">@dims_to_spatial_axes</span>
    <span class="k">def</span> <span class="nf">find_sm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;dog&quot;</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">95</span><span class="p">,</span>
        <span class="n">topn</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">exclude_border</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MarkerFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Single molecule detection using difference of Gaussian, determinant of Hessian, Laplacian of </span>
<span class="sd">        Gaussian or normalized cross correlation method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : float, optional</span>
<span class="sd">            Standard deviation of puncta.</span>
<span class="sd">        method : str {&quot;dog&quot;, &quot;doh&quot;, &quot;log&quot;, &quot;gaussian&quot;, &quot;ncc&quot;}, default is &quot;dog&quot;</span>
<span class="sd">            Which filter is used prior to finding local maxima. If &quot;ncc&quot;, a Gaussian particle is used as</span>
<span class="sd">            the template image.</span>
<span class="sd">        cutoff : float, optional</span>
<span class="sd">            Cutoff value of filtered image generated by `method`.</span>
<span class="sd">        percentile, topn, exclude_border, dims</span>
<span class="sd">            Passed to ``peak_local_max()``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkerFrame</span>
<span class="sd">            Peaks in uint16 type.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Track single molecules and view the tracks with napari.</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; coords = img.find_sm()</span>
<span class="sd">            &gt;&gt;&gt; lnk = coords.link(3, min_dwell=10)</span>
<span class="sd">            &gt;&gt;&gt; ip.gui.add(img)</span>
<span class="sd">            &gt;&gt;&gt; ip.gui.add(lnk)</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        centroid_sm</span>
<span class="sd">        refine_sm</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="s2">&quot;doh&quot;</span><span class="p">,</span> <span class="s2">&quot;log&quot;</span><span class="p">):</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cutoff</span>
            <span class="n">fil_img</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">+</span><span class="s2">&quot;_filter&quot;</span><span class="p">)(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,):</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cutoff</span>
            <span class="n">fil_img</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">+</span><span class="s2">&quot;_filter&quot;</span><span class="p">)(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;ncc&quot;</span><span class="p">:</span>
            <span class="c1"># make template Gaussian</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cutoff</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">check_nd</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)))</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">sigma</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">GaussianParticle</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># template matching</span>
            <span class="n">fil_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncc_filter</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`method` must be &#39;dog&#39;, &#39;doh&#39;, &#39;log&#39;, &#39;gaussian&#39; or &#39;ncc&#39;.&quot;</span><span class="p">)</span>
        
        <span class="n">fil_img</span><span class="p">[</span><span class="n">fil_img</span><span class="o">&lt;</span><span class="n">cutoff</span><span class="p">]</span> <span class="o">=</span> <span class="n">cutoff</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
            <span class="n">min_d</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">fil_img</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">min_distance</span><span class="o">=</span><span class="n">min_d</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">,</span> 
                                        <span class="n">topn</span><span class="o">=</span><span class="n">topn</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="n">exclude_border</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coords</span></div>
    
    
<div class="viewcode-block" id="ImgArray.centroid_sm"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.centroid_sm">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="k">def</span> <span class="nf">centroid_sm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">Coords</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="n">nDInt</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">filt</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ImgArray</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">find_sm_kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MarkerFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate positions of particles in subpixel precision using centroid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : MarkerFrame or (N, 2) array, optional</span>
<span class="sd">            Coordinates of peaks. If None, this will be determined by find_sm.</span>
<span class="sd">        radius : int, default is 4.</span>
<span class="sd">            Range to calculate centroids. Rectangular image with size 2r+1 x 2r+1 will be send </span>
<span class="sd">            to calculate moments.</span>
<span class="sd">        filt : callable, optional</span>
<span class="sd">            For every slice ``sl``, label is added only when filt(`input`) == True is satisfied.</span>
<span class="sd">        find_sm_kwargs : keyword arguments</span>
<span class="sd">            Parameters passed to :func:`find_sm`.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkerFrame</span>
<span class="sd">            Coordinates of peaks.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        find_sm</span>
<span class="sd">        refine_sm</span>
<span class="sd">        &quot;&quot;&quot;</span>     
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="kn">from</span> <span class="nn">..frame</span> <span class="kn">import</span> <span class="n">MarkerFrame</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_sm</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="o">**</span><span class="n">find_sm_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">_check_coordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">check_filter_func</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">check_nd</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">ndim</span><span class="p">))</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">.</span><span class="n">_axes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">crds</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">c_axes</span><span class="p">):</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">center</span> <span class="ow">in</span> <span class="n">crds</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="n">_specify_one</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
                <span class="n">input_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">sl</span><span class="p">][</span><span class="n">bbox</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">input_img</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">filt</span><span class="p">(</span><span class="n">input_img</span><span class="p">):</span>
                    <span class="k">continue</span>
                
                <span class="n">shift</span> <span class="o">=</span> <span class="n">center</span> <span class="o">-</span> <span class="n">radius</span>
                <span class="n">centroid</span> <span class="o">=</span> <span class="n">_calc_centroid</span><span class="p">(</span><span class="n">input_img</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span> <span class="o">+</span> <span class="n">shift</span>
                
                <span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">df</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">c_axes</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[:</span><span class="o">-</span><span class="n">ndim</span><span class="p">]</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No molecule found.&quot;</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="n">MarkerFrame</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">_axes</span><span class="p">)),</span>
                            <span class="n">columns</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">_axes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">as_standard_type</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.edge_grad"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.edge_grad">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">edge_grad</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sobel&quot;</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PhaseArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate gradient direction using horizontal and vertical edge operation. Gradient direction</span>
<span class="sd">        is the direction with maximum gradient, i.e., intensity increase is largest. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {sigma}</span>
<span class="sd">        method : str, {&quot;sobel&quot;, &quot;farid&quot;, &quot;scharr&quot;, &quot;prewitt&quot;}, default is &quot;sobel&quot;</span>
<span class="sd">            Edge operator name.</span>
<span class="sd">        deg : bool, default is True</span>
<span class="sd">            If True, degree rather than radian is returned.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PhaseArray</span>
<span class="sd">            Phase image with range [-180, 180) if deg==True, otherwise [-pi, pi).</span>
<span class="sd">            </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        1. Profile filament orientation distribution using histogram of edge gradient.</span>
<span class="sd">            &gt;&gt;&gt; grad = img.edge_grad(deg=True)</span>
<span class="sd">            &gt;&gt;&gt; plt.hist(grad.ravel(), bins=100)</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># Get operator</span>
        <span class="n">method_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sobel&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">skfil</span><span class="o">.</span><span class="n">sobel_h</span><span class="p">,</span> <span class="n">skfil</span><span class="o">.</span><span class="n">sobel_v</span><span class="p">),</span>
                       <span class="s2">&quot;farid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">skfil</span><span class="o">.</span><span class="n">farid_h</span><span class="p">,</span> <span class="n">skfil</span><span class="o">.</span><span class="n">farid_v</span><span class="p">),</span>
                       <span class="s2">&quot;scharr&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">skfil</span><span class="o">.</span><span class="n">scharr_h</span><span class="p">,</span> <span class="n">skfil</span><span class="o">.</span><span class="n">scharr_v</span><span class="p">),</span>
                       <span class="s2">&quot;prewitt&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">skfil</span><span class="o">.</span><span class="n">prewitt_h</span><span class="p">,</span> <span class="n">skfil</span><span class="o">.</span><span class="n">prewitt_v</span><span class="p">)}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">op_h</span><span class="p">,</span> <span class="n">op_v</span> <span class="o">=</span> <span class="n">method_dict</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`method` must be &#39;sobel&#39;, &#39;farid&#39; &#39;scharr&#39;, or &#39;prewitt&#39;.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Start</span>
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">grad_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span><span class="n">op_h</span><span class="p">,</span> <span class="n">c_axes</span><span class="o">=</span><span class="n">c_axes</span><span class="p">)</span>
        <span class="n">grad_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span><span class="n">op_v</span><span class="p">,</span> <span class="n">c_axes</span><span class="o">=</span><span class="n">c_axes</span><span class="p">)</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">grad_h</span><span class="p">,</span> <span class="n">grad_v</span><span class="p">)</span>
        
        <span class="n">grad</span> <span class="o">=</span> <span class="n">PhaseArray</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="n">border</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">grad</span><span class="o">.</span><span class="n">_fix_border</span><span class="p">()</span>
        <span class="n">deg</span> <span class="ow">and</span> <span class="n">grad</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">grad</span></div>
    
<div class="viewcode-block" id="ImgArray.hessian_angle"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.hessian_angle">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">hessian_angle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="n">nDFloat</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PhaseArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate filament angles using Hessian&#39;s eigenvectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {sigma}</span>
<span class="sd">        deg : bool, default is False</span>
<span class="sd">            If True, returned array will be in degree. Otherwise, radian will be the unit</span>
<span class="sd">            of angle.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Phase image with range [-90, 90] if ``deg==True``, otherwise [-pi/2, pi/2].</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        gabor_angle</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">_</span><span class="p">,</span> <span class="n">eigvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hessian_eig</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">get_formatter</span><span class="p">([</span><span class="s2">&quot;dim&quot;</span><span class="p">,</span> <span class="s2">&quot;base&quot;</span><span class="p">])</span>
        
        <span class="n">arg</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">eigvec</span><span class="p">[</span><span class="n">fmt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">eigvec</span><span class="p">[</span><span class="n">fmt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">PhaseArray</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">border</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">arg</span><span class="o">.</span><span class="n">_fix_border</span><span class="p">()</span>
        <span class="n">deg</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">arg</span></div>
    
<div class="viewcode-block" id="ImgArray.gabor_angle"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.gabor_angle">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">gabor_angle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_sample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">180</span><span class="p">,</span>
        <span class="n">lmd</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> 
        <span class="n">phi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PhaseArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate filament angles using Gabor filter. For all the candidates of angles, Gabor response is</span>
<span class="sd">        calculated, and the strongest response is returned as output array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_sample : int, default is 180</span>
<span class="sd">            Number of `theta`s to calculate. By default, -90, -89, ..., 89 degree are calculated.</span>
<span class="sd">        lmd : float, default is 5</span>
<span class="sd">            Wave length of Gabor kernel. Make sure that the diameter of the objects you want to detect is</span>
<span class="sd">            around `lmd/2`.</span>
<span class="sd">        sigma : float, default is 2.5</span>
<span class="sd">            Standard deviation of Gaussian factor of Gabor kernel.</span>
<span class="sd">        gamma : float, default is 1</span>
<span class="sd">            Anisotropy of Gabor kernel, i.e. the standard deviation orthogonal to theta will be sigma/gamma.</span>
<span class="sd">        phi : float, default is 0</span>
<span class="sd">            Phase offset of harmonic factor of Gabor kernel.</span>
<span class="sd">        deg : bool, default is False</span>
<span class="sd">            If True, degree rather than radian is returned.</span>
<span class="sd">        {dims}</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Phase image with range [-90, 90) if deg==True, otherwise [-pi/2, pi/2).</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hessian_angle</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_sample</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">max_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">argmax_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># This is float32 because finally this becomes angle array.</span>
        
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thetas</span><span class="p">):</span>
            <span class="n">ker</span> <span class="o">=</span> <span class="n">skfil</span><span class="o">.</span><span class="n">gabor_kernel</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lmd</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">sigma</span><span class="o">/</span><span class="n">gamma</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
            <span class="n">out_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span><span class="n">_filters</span><span class="o">.</span><span class="n">convolve</span><span class="p">,</span> 
                                              <span class="n">c_axes</span><span class="o">=</span><span class="n">c_axes</span><span class="p">,</span> 
                                              <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ker</span><span class="o">.</span><span class="n">real</span><span class="p">,)</span>
                                              <span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">where_update</span> <span class="o">=</span> <span class="n">out_</span> <span class="o">&gt;</span> <span class="n">max_</span>
                <span class="n">max_</span><span class="p">[</span><span class="n">where_update</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_</span><span class="p">[</span><span class="n">where_update</span><span class="p">]</span>
                <span class="n">argmax_</span><span class="p">[</span><span class="n">where_update</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_</span> <span class="o">=</span> <span class="n">out_</span>
        <span class="n">argmax_</span> <span class="o">*=</span> <span class="p">(</span><span class="n">thetas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">thetas</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">argmax_</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">argmax_</span>
        
        <span class="n">argmax_</span> <span class="o">=</span> <span class="n">PhaseArray</span><span class="p">(</span><span class="n">argmax_</span><span class="p">,</span> <span class="n">border</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">argmax_</span><span class="o">.</span><span class="n">_fix_border</span><span class="p">()</span>
        <span class="n">deg</span> <span class="ow">and</span> <span class="n">argmax_</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">argmax_</span></div>
    
<div class="viewcode-block" id="ImgArray.gabor_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.gabor_filter">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">gabor_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lmd</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span>
        <span class="n">return_imag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a Gabor kernel and convolve it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lmd : float, default is 5</span>
<span class="sd">            Wave length of Gabor kernel. Make sure that the diameter of the objects you want to detect is</span>
<span class="sd">            around `lmd/2`.</span>
<span class="sd">        theta : float, default is 0</span>
<span class="sd">            Orientation of harmonic factor of Gabor kernel in radian (x-directional if `theta==0`).</span>
<span class="sd">        {sigma}</span>
<span class="sd">        gamma : float, default is 1</span>
<span class="sd">            Anisotropy of Gabor kernel, i.e. the standard deviation orthogonal to theta will be sigma/gamma.</span>
<span class="sd">        phi : float, default is 0</span>
<span class="sd">            Phase offset of harmonic factor of Gabor kernel.</span>
<span class="sd">        return_imag : bool, default is False</span>
<span class="sd">            If True, a complex image that contains both real and imaginary part of Gabor response is returned.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray (dtype is float32 or complex64)</span>
<span class="sd">            Filtered image.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Edge Detection using multi-angle Gabor filtering.</span>
<span class="sd">            &gt;&gt;&gt; thetas = np.deg2rad([0, 45, 90, 135])</span>
<span class="sd">            &gt;&gt;&gt; out = np.zeros((4,)+img.shape, dtype=np.float32)</span>
<span class="sd">            &gt;&gt;&gt; for i, theta in enumerate(thetas):</span>
<span class="sd">            &gt;&gt;&gt;     out[i] = img.gabor_filter(theta=theta)</span>
<span class="sd">            &gt;&gt;&gt; out = np.max(out, axis=0)</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># TODO: 3D Gabor filter</span>
        <span class="n">ker</span> <span class="o">=</span> <span class="n">skfil</span><span class="o">.</span><span class="n">gabor_kernel</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lmd</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">sigma</span><span class="o">/</span><span class="n">gamma</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_imag</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
                <span class="n">_filters</span><span class="o">.</span><span class="n">gabor_filter</span><span class="p">,</span> 
                <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ker</span><span class="p">,),</span> 
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
                <span class="n">_filters</span><span class="o">.</span><span class="n">convolve</span><span class="p">,</span> 
                <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ker</span><span class="o">.</span><span class="n">real</span><span class="p">,),</span> 
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.fft"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.fft">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">fft</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">shape</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">FftShape</span> <span class="o">=</span> <span class="s2">&quot;same&quot;</span><span class="p">,</span>
        <span class="n">shift</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
        <span class="n">double_precision</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fast Fourier transformation. This function returns complex array, which is</span>
<span class="sd">        inconpatible with some ImgArray functions.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : int, iterable of int, &quot;square&quot; or &quot;same&quot;</span>
<span class="sd">            Output shape. Input image is padded or cropped according to this value:</span>
<span class="sd">            - integers: padded or cropped to the specified shape.</span>
<span class="sd">            - &quot;square&quot;: padded to smallest 2^N-long square.</span>
<span class="sd">            - &quot;same&quot; (default): no padding or cropping.</span>
<span class="sd">        shift : bool, default is True</span>
<span class="sd">            If True, call ``np.fft.fftshift`` in the end.</span>
<span class="sd">        {double_precision}</span>
<span class="sd">        {dims}</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            FFT image.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        local_dft</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axisof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;square&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">))))</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;same&quot;</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="k">if</span> <span class="n">double_precision</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shift</span><span class="p">:</span>
            <span class="n">freq</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.local_dft"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.local_dft">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">local_dft</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">AxesTargetedSlicer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upsample_factor</span><span class="p">:</span> <span class="n">nDInt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">double_precision</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Local discrete Fourier transformation (DFT). This function will be useful </span>
<span class="sd">        for Fourier transformation of small region of an image with a certain</span>
<span class="sd">        factor of up-sampling. In general FFT takes :math:`O(N\log{N})` time, much</span>
<span class="sd">        faster compared to normal DFT (:math:`O(N^2)`). However, If you are </span>
<span class="sd">        interested in certain region of Fourier space, you don&#39;t have to calculate </span>
<span class="sd">        all the spectra. In this case DFT is faster and less memory comsuming.</span>
<span class="sd">        </span>
<span class="sd">            .. warning::</span>
<span class="sd">                The result of ``local_dft`` will **NOT** be shifted with </span>
<span class="sd">                ``np.fft.fftshift`` because in general the center of arrays are</span>
<span class="sd">                unknown. Also, it is easier to understand `x=0` corresponds to the</span>
<span class="sd">                center.</span>
<span class="sd">        </span>
<span class="sd">        Even whole spectrum is returned, ``local_dft`` may be faster than FFT with </span>
<span class="sd">        small and/or non-FFT-friendly shaped image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            Key string that specify region to DFT, such as &quot;y=-50:10;x=:80&quot;. With</span>
<span class="sd">            upsampled spectra, keys corresponds to the coordinate **before** </span>
<span class="sd">            up-sampling. If you want certain region, say &quot;x=10:20&quot;, this value </span>
<span class="sd">            will not change with different ``upsample_factor``.</span>
<span class="sd">        upsample_factor : int or array of int, default is 1</span>
<span class="sd">            Up-sampling factor. For instance, when ``upsample_factor=10`` a single</span>
<span class="sd">            pixel will be expanded to 10 pixels.</span>
<span class="sd">        {double_precision}</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            DFT output.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fft</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">upsample_factor</span> <span class="o">=</span> <span class="n">check_nd</span><span class="p">(</span><span class="n">upsample_factor</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
        
        <span class="c1"># determine how to slice the result of FFT</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="p">)</span> <span class="o">*</span> <span class="n">ndim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="n">solve_slicer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Axes</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="k">if</span> <span class="n">double_precision</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span>
        
        <span class="c1"># Calculate exp(-ikx)</span>
        <span class="c1"># To minimize floating error, the A term in exp(-2*pi*i*A) should be in the range of </span>
        <span class="c1"># 0 &lt;= A &lt; 1.</span>
        <span class="n">exps</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">xp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">xp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">xp</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">wave_num</span><span class="p">(</span><span class="n">sl</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">uf</span><span class="p">)</span> <span class="o">*</span> <span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">uf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">upsample_factor</span><span class="p">)]</span>
        
        <span class="c1"># Calculate chunk size for proper output shapes</span>
        <span class="n">out_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">out_chunks</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">exps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out_chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_chunks</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_misc</span><span class="o">.</span><span class="n">dft</span><span class="p">,</span> 
            <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> 
            <span class="n">out_chunks</span><span class="o">=</span><span class="n">out_chunks</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">exps</span><span class="o">=</span><span class="n">exps</span><span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.local_power_spectra"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.local_power_spectra">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">local_power_spectra</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">AxesTargetedSlicer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upsample_factor</span><span class="p">:</span> <span class="n">nDInt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">norm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">double_precision</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return local n-D power spectra of images. See ``local_dft``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            Key string that specify region to DFT, such as &quot;y=-50:10;x=:80&quot;. With Upsampled spectra, keys</span>
<span class="sd">            corresponds to the coordinate **before** up-sampling. If you want certain region, say &quot;x=10:20&quot;,</span>
<span class="sd">            this value will not change with different ``upsample_factor``.</span>
<span class="sd">        upsample_factor : int or array of int, default is 1</span>
<span class="sd">            Up-sampling factor. For instance, when ``upsample_factor=10`` a single pixel will be expanded to</span>
<span class="sd">            10 pixels.</span>
<span class="sd">        norm : bool, default is False</span>
<span class="sd">            If True, maximum value of power spectra is adjusted to 1.</span>
<span class="sd">        {double_precision}</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Power spectra</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        power_spectra</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_dft</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">upsample_factor</span><span class="o">=</span><span class="n">upsample_factor</span><span class="p">,</span> 
                              <span class="n">double_precision</span><span class="o">=</span><span class="n">double_precision</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">pw</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">freq</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
            <span class="n">pw</span> <span class="o">/=</span> <span class="n">pw</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pw</span></div>
    
<div class="viewcode-block" id="ImgArray.ifft"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.ifft">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">ifft</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">real</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">shift</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">double_precision</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fast Inverse Fourier transformation. Complementary function with `fft()`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        real : bool, default is True</span>
<span class="sd">            If True, only the real part is returned.</span>
<span class="sd">        shift : bool, default is True</span>
<span class="sd">            If True, call ``np.fft.ifftshift`` at the first.</span>
<span class="sd">        {double_precision}</span>
<span class="sd">        {dims}</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            IFFT image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axisof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">shift</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="k">if</span> <span class="n">double_precision</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span>
            <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> 
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">real</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.power_spectra"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.power_spectra">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">power_spectra</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">FftShape</span> <span class="o">=</span> <span class="s2">&quot;same&quot;</span><span class="p">,</span>
        <span class="n">norm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
        <span class="n">zero_norm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
        <span class="n">double_precision</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return n-D power spectra of images, which is defined as:</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            P = Re(F[I_{img}])^2 + Im(F[I_{img}])^2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : int, iterable of int, &quot;square&quot; or &quot;same&quot;</span>
<span class="sd">            Output shape. Input image is padded or cropped according to this value:</span>
<span class="sd">            - integers: padded or cropped to the specified shape.</span>
<span class="sd">            - &quot;square&quot;: padded to smallest 2^N-long square.</span>
<span class="sd">            - &quot;same&quot; (default): no padding or cropping.</span>
<span class="sd">        norm : bool, default is False</span>
<span class="sd">            If True, maximum value of power spectra is adjusted to 1.</span>
<span class="sd">        {double_precision}</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Power spectra</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        local_power_spectra</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">double_precision</span><span class="o">=</span><span class="n">double_precision</span><span class="p">)</span>
        <span class="n">pw</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">freq</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
            <span class="n">pw</span> <span class="o">/=</span> <span class="n">pw</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">pw</span><span class="p">:</span> <span class="n">ImgArray</span>
        <span class="k">if</span> <span class="n">zero_norm</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">switch_slice</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">pw</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">ifin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pw</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">ifnot</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="n">pw</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">pw</span></div>

<div class="viewcode-block" id="ImgArray.radon"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.radon">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="k">def</span> <span class="nf">radon</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">degrees</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> 
        <span class="o">*</span><span class="p">,</span>
        <span class="n">central_axis</span><span class="p">:</span> <span class="n">AxisLike</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Discrete Radon transformation of 2D or 3D image.</span>
<span class="sd">        </span>
<span class="sd">        Radon transformation is a list of projection of a same image from different angles.</span>
<span class="sd">        It generates tomographic n-D image slices from (n+1)-D image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        degrees : float or iterable of float</span>
<span class="sd">            Rotation angles around the central axis in degrees.</span>
<span class="sd">        central_axis : axis-like or sequence of float, optional</span>
<span class="sd">            Vector that defines the central axis of rotation.</span>
<span class="sd">        {order}{dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Tomographic image slices. The first spatial axis (&quot;z&quot; for zyx-image) will be dropped.</span>
<span class="sd">            If sequence of float is given as ``degrees``, &quot;degree&quot; axis will be newly added at</span>
<span class="sd">            the position 0. For instance, if a zyx-image and ``degrees=np.linspace(0, 180, 100)``</span>
<span class="sd">            are given, returned image has axes [&quot;degree&quot;, &quot;y&quot;, &quot;x&quot;].</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iradon</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">da</span><span class="p">,</span> <span class="n">delayed</span>
        
        <span class="n">params</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">,</span> <span class="n">squeeze</span> <span class="o">=</span> <span class="n">_transform</span><span class="o">.</span><span class="n">normalize_radon_input</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">central_axis</span><span class="p">,</span> <span class="n">degrees</span>
        <span class="p">)</span>
        
        <span class="c1"># apply spline filter in advance.</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">spline_filter</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="n">delayed_func</span> <span class="o">=</span> <span class="n">delayed</span><span class="p">(</span><span class="n">_transform</span><span class="o">.</span><span class="n">radon_single</span><span class="p">)</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">delayed_func</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">)</span> 
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span>
        <span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">tasks</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;degree&quot;</span><span class="p">))</span>
        <span class="n">out</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.iradon"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.iradon">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="k">def</span> <span class="nf">iradon</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">degrees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">central_axis</span><span class="p">:</span> <span class="n">AxisLike</span> <span class="o">=</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span>
        <span class="n">degree_axis</span><span class="p">:</span> <span class="n">AxisLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">height_axis</span><span class="p">:</span> <span class="n">AxisLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hamming&quot;</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse Radon transformation (weighted back projection) of a tile series.</span>
<span class="sd">        </span>
<span class="sd">        Input array must be a tilt series of 1D or 2D images. They are back-</span>
<span class="sd">        projected into a 2D or 3D image with arbitrary height.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        degrees : sequence of float</span>
<span class="sd">            Projection angles in degree. Length must match the length of the degree</span>
<span class="sd">            axis of the input image.</span>
<span class="sd">        central_axis : AxisLike, optional</span>
<span class="sd">            Axis parallel to the rotation axis.</span>
<span class="sd">        degree_axis : AxisLike, optional</span>
<span class="sd">            Axis of rotation degree. By default, the first axis will be used.</span>
<span class="sd">        height_axis : AxisLike, optional</span>
<span class="sd">            Axis that will be used to label the new axis after reconstruction. For</span>
<span class="sd">            instance, if input image has axes ``[&quot;degree&quot;, &quot;y&quot;, &quot;x&quot;]`` and </span>
<span class="sd">            ``height_axis=&quot;z&quot;`` then reconstructed image will have axes </span>
<span class="sd">            ``[&quot;z&quot;, &quot;y&quot;, &quot;x&quot;]``. By default, &quot;y&quot; will be used for 2D input or &quot;z&quot; for</span>
<span class="sd">            3D input.</span>
<span class="sd">        height : int, optional</span>
<span class="sd">            Height of reconstruction. By default, size equal to the axis perpendicular</span>
<span class="sd">            to the rotation axis will be used.</span>
<span class="sd">        window : str, default is &quot;hamming&quot;</span>
<span class="sd">            Window function that will be applied to the Fourier domain along the axis</span>
<span class="sd">            perpendicular to the rotation axis.</span>
<span class="sd">        {order}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Reconstruction.</span>
<span class="sd">            </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        radon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;cubic&quot;</span><span class="p">}[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">central_axis</span><span class="p">,</span> <span class="n">degree_axis</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">,</span> <span class="n">new_axes</span> <span class="o">=</span> <span class="n">_transform</span><span class="o">.</span><span class="n">normalize_iradon_input</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">central_axis</span><span class="p">,</span> <span class="n">height_axis</span><span class="p">,</span> <span class="n">degree_axis</span><span class="p">,</span> <span class="n">height</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">ImgArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisof</span><span class="p">(</span><span class="n">degree_axis</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">filter_func</span> <span class="o">=</span> <span class="n">_transform</span><span class="o">.</span><span class="n">get_fourier_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">window</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_transform</span><span class="o">.</span><span class="n">iradon</span><span class="p">,</span>
            <span class="n">c_axes</span><span class="o">=</span><span class="p">[</span><span class="n">central_axis</span><span class="p">],</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span>
                <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                <span class="n">filter_func</span><span class="o">=</span><span class="n">filter_func</span><span class="p">,</span>
                <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="ImgArray.threshold"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.threshold">[docs]</a>    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">threshold</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">thr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">ThreasholdMethod</span> <span class="o">=</span> <span class="s2">&quot;otsu&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">along</span><span class="p">:</span> <span class="n">AxisLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply thresholding to the image and create a binary image.</span>
<span class="sd">        </span>
<span class="sd">        The threshold value can be given with a float or a string that indicates what</span>
<span class="sd">        thresholding method will be used.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        thr: float or str, optional</span>
<span class="sd">            Threshold value, percentage or thresholding algorithm.</span>
<span class="sd">        along : AxisLike, optional</span>
<span class="sd">            Dimensions that will not share the same threshold. For instance, if</span>
<span class="sd">            ``along=&quot;c&quot;`` then threshold intensities are determined for every channel.</span>
<span class="sd">            If ``thr`` is float, ``along`` will be ignored.</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            Keyword arguments that will passed to function indicated in &#39;method&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Boolian array.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Substitute outliers to 0.</span>
<span class="sd">            &gt;&gt;&gt; thr = img.threshold(&quot;99%&quot;)</span>
<span class="sd">            &gt;&gt;&gt; img[thr] = 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        
        <span class="k">if</span> <span class="n">along</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">along</span> <span class="o">=</span> <span class="s2">&quot;c&quot;</span> <span class="k">if</span> <span class="s2">&quot;c&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>

        <span class="n">methods_</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;isodata&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">threshold_isodata</span><span class="p">,</span>
                    <span class="s2">&quot;li&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">threshold_li</span><span class="p">,</span>
                    <span class="s2">&quot;local&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">threshold_local</span><span class="p">,</span>
                    <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">threshold_mean</span><span class="p">,</span>
                    <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">threshold_minimum</span><span class="p">,</span>
                    <span class="s2">&quot;minimum&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">threshold_minimum</span><span class="p">,</span>
                    <span class="s2">&quot;niblack&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">threshold_niblack</span><span class="p">,</span>
                    <span class="s2">&quot;otsu&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">threshold_otsu</span><span class="p">,</span>
                    <span class="s2">&quot;sauvola&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">threshold_sauvola</span><span class="p">,</span>
                    <span class="s2">&quot;triangle&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">threshold_triangle</span><span class="p">,</span>
                    <span class="s2">&quot;yen&quot;</span><span class="p">:</span> <span class="n">skfil</span><span class="o">.</span><span class="n">threshold_yen</span>
                    <span class="p">}</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thr</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">thr</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">thr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">along</span><span class="p">):</span>
                <span class="n">thr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span> <span class="o">&gt;=</span> <span class="n">thr</span>
                
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">thr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">methods_</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">methods_</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="se">\n</span><span class="s2">method must be: </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">along</span><span class="p">):</span>
                <span class="n">thr</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span> <span class="o">&gt;=</span> <span class="n">thr</span>
            

        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">thr</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&gt;=</span> <span class="n">thr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;thr&#39; must be numeric, or str specifying a thresholding method.&quot;</span>
            <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.distance_map"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.distance_map">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span><span class="p">(</span><span class="n">only_binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">distance_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate distance map from binary images.</span>
<span class="sd">        For instance, ``[1, 1, 1, 0, 0, 0, 1, 1, 1]`` will be converted to </span>
<span class="sd">        ``[3, 2, 1, 0, 0, 0, 1, 2, 3]``. Note that returned array will be float in n-D </span>
<span class="sd">        images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Distance map, the further the brighter</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span><span class="n">ndi</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">,</span> 
                               <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
                               <span class="p">)</span></div>
        
<div class="viewcode-block" id="ImgArray.ncc_filter"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.ncc_filter">[docs]</a>    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">ncc_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">template</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> 
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Template matching using normalized cross correlation (NCC) method. This function is basically</span>
<span class="sd">        identical to that in `skimage.feature`, but is optimized for batch processing and improved </span>
<span class="sd">        readability.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        template : np.ndarray</span>
<span class="sd">            Template image. Must be 2 or 3 dimensional. </span>
<span class="sd">        {mode}</span>
<span class="sd">        cval : float, optional</span>
<span class="sd">            Background intensity. If not given, it will calculated as the mean value of </span>
<span class="sd">            the original image.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Response image with values between -1 and 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">template</span> <span class="o">=</span> <span class="n">_check_template</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">cval</span><span class="p">):</span>
            <span class="n">cval</span> <span class="o">=</span> <span class="n">cval</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">cval</span> <span class="o">=</span> <span class="n">_check_bg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cval</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="n">template</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dims and the number of template dimension don&#39;t match.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">ncc_filter</span><span class="p">,</span>
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.remove_large_objects"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.remove_large_objects">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span><span class="p">(</span><span class="n">only_binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">remove_large_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove large objects using opening. Those objects that were not removed by opening</span>
<span class="sd">        will be removed in output.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        radius : float, optional</span>
<span class="sd">            Objects with radius larger than this value will be removed.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Image with large objects removed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        remove_fine_objects</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">large_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opening</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">large_obj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.remove_fine_objects"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.remove_fine_objects">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span><span class="p">(</span><span class="n">only_binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">remove_fine_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove fine objects using diameter_opening.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        length : float, default is 10</span>
<span class="sd">            Objects longer than this will be removed.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Image with large objects removed.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        remove_large_objects</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">fine_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter_opening</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="n">large_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opening</span><span class="p">(</span><span class="n">length</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">~</span><span class="n">large_obj</span> <span class="o">&amp;</span> <span class="n">fine_obj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.convex_hull"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.convex_hull">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span><span class="p">(</span><span class="n">only_binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">convex_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute convex hull image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Convex hull image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">convex_hull_image</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="ImgArray.skeletonize"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.skeletonize">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span><span class="p">(</span><span class="n">only_binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">skeletonize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Skeletonize images. Only works for binary images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        radius : float, optional</span>
<span class="sd">            Radius of skeleton. This is achieved simply by dilation of skeletonized results.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Skeletonized image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="n">radius</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">selem</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">_structures</span><span class="o">.</span><span class="n">ball_like</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selem</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">skeletonize</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">selem</span><span class="p">,),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="ImgArray.count_neighbors"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.count_neighbors">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span><span class="p">(</span><span class="n">only_binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">count_neighbors</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">connectivity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number or neighbors of binary images. This function can be used for cross section</span>
<span class="sd">        or branch detection. Only works for binary images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {connectivity}</span>
<span class="sd">        mask : bool, default is True</span>
<span class="sd">            If True, only neighbors of pixels that satisfy self==True is returned.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            uint8 array of the number of neighbors.</span>
<span class="sd">            </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">            &gt;&gt;&gt; skl = img.threshold().skeletonize()</span>
<span class="sd">            &gt;&gt;&gt; edge = skl.count_neighbors()</span>
<span class="sd">            &gt;&gt;&gt; np.argwhere(edge == 1) # get coordinates of filament edges.</span>
<span class="sd">            &gt;&gt;&gt; np.argwhere(edge &gt;= 3) # get coordinates of filament cross sections.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="n">ndim</span> <span class="k">if</span> <span class="n">connectivity</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">connectivity</span>
        <span class="n">selem</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">)</span>
        <span class="n">selem</span><span class="p">[(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="n">ndim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_uint8</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_filters</span><span class="o">.</span><span class="n">population</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">selem</span><span class="p">,)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.remove_skeleton_structure"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.remove_skeleton_structure">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span><span class="p">(</span><span class="n">only_binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">remove_skeleton_structure</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">structure</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;tip&quot;</span><span class="p">,</span> <span class="s2">&quot;branch&quot;</span><span class="p">,</span> <span class="s2">&quot;cross&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;tip&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">connectivity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove certain structure from skeletonized images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        structure : str, default is &quot;tip&quot;</span>
<span class="sd">            What type of structure to remove.</span>
<span class="sd">        {connectivity}</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Processed image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">neighbor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_neighbors</span><span class="p">(</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;tip&quot;</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">neighbor</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;branch&quot;</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">neighbor</span> <span class="o">&gt;</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;cross&quot;</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">neighbor</span> <span class="o">&gt;</span> <span class="mi">3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`mode` must be one of {&#39;tip&#39;, &#39;branch&#39;, &#39;cross&#39;}.&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.watershed"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.watershed">[docs]</a>    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span><span class="p">(</span><span class="n">need_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">watershed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">MarkerFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">connectivity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nb">input</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;distance&quot;</span><span class="p">,</span> 
        <span class="n">min_distance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Label</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Label segmentation using watershed algorithm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : MarkerFrame, optional</span>
<span class="sd">            Returned by such as `peak_local_max()`. Array of coordinates of peaks.</span>
<span class="sd">        {connectivity}</span>
<span class="sd">        input : str, optional</span>
<span class="sd">            What image will be the input of watershed algorithm.            </span>
<span class="sd">            </span>
<span class="sd">            - &quot;self&quot; ... self is used.</span>
<span class="sd">            - &quot;distance&quot; ... distance map of self.labels is used.</span>
<span class="sd">            </span>
<span class="sd">        {dims}</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Label</span>
<span class="sd">            Updated labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Prepare the input image.</span>
        <span class="k">if</span> <span class="nb">input</span> <span class="o">==</span> <span class="s2">&quot;self&quot;</span><span class="p">:</span>
            <span class="n">input_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">input</span> <span class="o">==</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span>
            <span class="n">input_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span><span class="o">.</span><span class="n">distance_map</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;input_&#39; must be either &#39;self&#39; or &#39;distance&#39;.&quot;</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">input_img</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">input_img</span> <span class="o">=</span> <span class="n">input_img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            
        <span class="n">input_img</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
        
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">input_img</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">min_distance</span><span class="o">=</span><span class="n">min_distance</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        
        <span class="n">labels</span> <span class="o">=</span> <span class="n">largest_zeros</span><span class="p">(</span><span class="n">input_img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">n_labels</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">markers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">labels</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># placeholder for maxima</span>
        <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">crd</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">c_axes</span><span class="p">):</span>
            <span class="c1"># crd.values is (N, 2) array so tuple(crd.values.T.tolist()) is two (N,) list.</span>
            <span class="n">crd</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">markers</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">crd</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">crd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">labels</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">skseg</span><span class="o">.</span><span class="n">watershed</span><span class="p">(</span><span class="o">-</span><span class="n">input_img</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span> <span class="n">markers</span><span class="p">,</span> 
                                        <span class="n">mask</span><span class="o">=</span><span class="n">input_img</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span> 
                                        <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">sl</span><span class="p">][</span><span class="n">labels</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n_labels</span>
            <span class="n">n_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">markers</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># reset placeholder</span>
        
        <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">Label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span></div>
    
<div class="viewcode-block" id="ImgArray.random_walker"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.random_walker">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span><span class="p">(</span><span class="n">need_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">random_walker</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">130</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;cg&quot;</span><span class="p">,</span> <span class="s2">&quot;cg_j&quot;</span><span class="p">,</span> <span class="s2">&quot;cg_mg&quot;</span><span class="p">,</span> <span class="s2">&quot;bf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cg_j&quot;</span><span class="p">,</span> 
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Label</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Random walker segmentation. Only wrapped skimage segmentation. </span>
<span class="sd">        </span>
<span class="sd">        ``self.labels`` will be segmented and updated inplace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beta, mode, tol</span>
<span class="sd">            see skimage.segmentation.random_walker</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Relabeled image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">c_axes</span><span class="p">,</span> <span class="n">israw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">img</span><span class="o">.</span><span class="n">labels</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">skseg</span><span class="o">.</span><span class="n">random_walker</span><span class="p">(</span>
                <span class="n">img</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
            <span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span></div>
    
<div class="viewcode-block" id="ImgArray.label_threshold"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.label_threshold">[docs]</a>    <span class="k">def</span> <span class="nf">label_threshold</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">thr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">ThreasholdMethod</span> <span class="o">=</span> <span class="s2">&quot;otsu&quot;</span><span class="p">,</span>
        <span class="n">filt</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Label</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make labels with threshold(). Be sure that keyword argument ``dims`` can be</span>
<span class="sd">        different (in most cases for &gt;4D images) between threshold() and label().</span>
<span class="sd">        In this function, both function will have the same ``dims`` for simplicity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        thr: float or str or None, optional</span>
<span class="sd">            Threshold value, or thresholding algorithm.</span>
<span class="sd">        {dims}</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            Keyword arguments that will passed to function indicated in &#39;method&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Label</span>
<span class="sd">            Newly created label.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">thr</span><span class="o">=</span><span class="n">thr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ImgArray.regionprops"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.regionprops">[docs]</a>    <span class="k">def</span> <span class="nf">regionprops</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">properties</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;mean_intensity&quot;</span><span class="p">,),</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">extra_properties</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PropArray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multi-dimensional region property quantification.</span>
<span class="sd">        </span>
<span class="sd">        Run skimage&#39;s regionprops() function and return the results as PropArray, so</span>
<span class="sd">        that you can access using flexible slicing. For example, if a tcyx-image is</span>
<span class="sd">        analyzed with ``properties=(&quot;X&quot;, &quot;Y&quot;)``, then you can get X&#39;s time-course profile</span>
<span class="sd">        of channel 1 at label 3 by ``prop[&quot;X&quot;][&quot;p=5;c=1&quot;]`` or ``prop.X[&quot;p=5;c=1&quot;]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        properties : iterable, optional</span>
<span class="sd">            properties to analyze, see ``skimage.measure.regionprops``.</span>
<span class="sd">        extra_properties : iterable of callable, optional</span>
<span class="sd">            extra properties to analyze, see ``skimage.measure.regionprops``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataDict of PropArray</span>
<span class="sd">            Dictionary has keys of properties that are specified by `properties`. Each value</span>
<span class="sd">            has the array of properties.</span>
<span class="sd">            </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Measure region properties around single molecules.</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; coords = img.centroid_sm()</span>
<span class="sd">            &gt;&gt;&gt; img.specify(coords, 3, labeltype=&quot;circle&quot;)</span>
<span class="sd">            &gt;&gt;&gt; props = img.regionprops()</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">id_axis</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">properties</span> <span class="o">=</span> <span class="p">(</span><span class="n">properties</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">extra_properties</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">properties</span> <span class="o">=</span> <span class="n">properties</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">extra_properties</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">id_axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="c1"># this dimension will be label</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis &#39;</span><span class="si">{</span><span class="n">id_axis</span><span class="si">}</span><span class="s2">&#39; is used for label ID in DataFrames.&quot;</span><span class="p">)</span>
        
        <span class="n">prop_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">prop_axes</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">DataDict</span><span class="p">({</span><span class="n">p</span><span class="p">:</span> <span class="n">PropArray</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">max</span><span class="p">(),)</span> <span class="o">+</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;-prop&quot;</span><span class="p">,</span> 
                <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="n">id_axis</span><span class="p">]</span><span class="o">+</span><span class="n">prop_axes</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span>
                <span class="n">propname</span><span class="o">=</span><span class="n">p</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">properties</span>
            <span class="p">})</span>
        
        <span class="c1"># calculate property value for each slice</span>
        <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">prop_axes</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">axes</span><span class="p">):</span>
            <span class="n">props</span> <span class="o">=</span> <span class="n">skmes</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">extra_properties</span><span class="o">=</span><span class="n">extra_properties</span><span class="p">)</span>
            <span class="n">label_sl</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="n">sl</span>
            <span class="k">for</span> <span class="n">prop_name</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
                <span class="c1"># Both sides have length of id_axis (number of labels) so that values</span>
                <span class="c1"># can be correctly substituted.</span>
                <span class="n">out</span><span class="p">[</span><span class="n">prop_name</span><span class="p">][</span><span class="n">label_sl</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">prop_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">props</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">parr</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">parr</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.lbp"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.lbp">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">lbp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="s2">&quot;ror&quot;</span><span class="p">,</span> <span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="s2">&quot;var&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Local binary pattern feature extraction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p : int, default is 12</span>
<span class="sd">            Number of circular neighbors</span>
<span class="sd">        radius : int, default is 1</span>
<span class="sd">            Radius of neighbours.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Method to determined the pattern.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Local binary pattern image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">skfeat</span><span class="o">.</span><span class="n">local_binary_pattern</span><span class="p">,</span>
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="p">)</span></div>
        
<div class="viewcode-block" id="ImgArray.glcm_props"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.glcm_props">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">glcm_props</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">properties</span><span class="p">:</span><span class="nb">tuple</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                   <span class="o">*</span><span class="p">,</span> <span class="n">bins</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale_max</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute properties of &quot;Gray Level Coocurrence Matrix&quot;. This will take long time</span>
<span class="sd">        because of pure Python for-loop.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        distances : array_like</span>
<span class="sd">            List of pixel pair distance offsets.</span>
<span class="sd">        angles : array_like</span>
<span class="sd">            List of pixel pair angles in radians.</span>
<span class="sd">        radius : int</span>
<span class="sd">            Window radius.</span>
<span class="sd">        properties : tuple of str</span>
<span class="sd">            contrast, dissimilarity, homogeneity, energy, mean, std, asm, max, entropy</span>
<span class="sd">        bins : int, optional</span>
<span class="sd">            Number of bins.</span>
<span class="sd">        rescale_max : bool, default is False</span>
<span class="sd">            If True, the contrast of the input image is maximized by multiplying an integer.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataDict of ImgArray</span>
<span class="sd">            GLCM with additional axes &quot;da&quot;, where &quot;d&quot; means distance and &quot;a&quot; means angle.</span>
<span class="sd">            If input image has &quot;tzyx&quot; axes then output will have &quot;tzd&lt;yx&quot; axes.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Plot GLCM&#39;s IDM and ASM images</span>
<span class="sd">            &gt;&gt;&gt; out = img.glcm_props([1], [0], 3, properties=(&quot;idm&quot;,&quot;asm&quot;))</span>
<span class="sd">            &gt;&gt;&gt; out.idm[&quot;d=0;&lt;=0&quot;].imshow()</span>
<span class="sd">            &gt;&gt;&gt; out.asm[&quot;d=0;&lt;=0&quot;].imshow()</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">rescale_max</span> <span class="o">=</span> <span class="n">_glcm</span><span class="o">.</span><span class="n">check_glcm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">rescale_max</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">properties</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">properties</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;contrast&quot;</span><span class="p">,</span> <span class="s2">&quot;dissimilarity&quot;</span><span class="p">,</span> <span class="s2">&quot;idm&quot;</span><span class="p">,</span> 
                          <span class="s2">&quot;asm&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;entropy&quot;</span><span class="p">,</span> <span class="s2">&quot;correlation&quot;</span><span class="p">)</span>
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">outshape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">c_axes</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizesof</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">prop</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">outshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">prop</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">prop</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">outshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;properties must be str or callable.&quot;</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">DataDict</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">c_axes</span><span class="p">):</span>
            <span class="n">propout</span> <span class="o">=</span> <span class="n">_glcm</span><span class="o">.</span><span class="n">glcm_props_</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">prop</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">propout</span><span class="p">[</span><span class="n">prop</span><span class="p">]</span>
            
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">v</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="n">c_axes</span><span class="o">+</span><span class="s2">&quot;da&quot;</span><span class="o">+</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
    
<div class="viewcode-block" id="ImgArray.proj"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.proj">[docs]</a>    <span class="nd">@same_dtype</span>
    <span class="k">def</span> <span class="nf">proj</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">AxisLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Projection along any axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : str, optional</span>
<span class="sd">            Along which axis projection will be calculated. If None, most plausible one will be chosen.</span>
<span class="sd">        method : str or callable, default is mean-projection.</span>
<span class="sd">            Projection method. If str is given, it will converted to numpy function.</span>
<span class="sd">        mask : array-like, optional</span>
<span class="sd">            If provided, input image will be converted to np.ma.array and ``method`` will also be interpreted</span>
<span class="sd">            as an masked functio if possible.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Other keyword arguments that will passed to projection function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Projected image.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># determine function</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">method</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">_check_function</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">find_first_appeared</span><span class="p">(</span><span class="s2">&quot;ztpiac&quot;</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="s2">&quot;yx&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">axisint</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axisof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s2">&quot;numpy.ma.core&quot;</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axisint</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axisint</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axisint</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axisint</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">axisint</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="ImgArray.clip"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.clip">[docs]</a>    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_range</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;0%&quot;</span><span class="p">,</span> <span class="s2">&quot;100%&quot;</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saturate low/high intensity using np.clip().</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_range : two scalar values, optional</span>
<span class="sd">            range of lower/upper limits, by default (0%, 100%).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Clipped image with temporal attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">lowerlim</span><span class="p">,</span> <span class="n">upperlim</span> <span class="o">=</span> <span class="n">_check_clip_range</span><span class="p">(</span><span class="n">in_range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">lowerlim</span><span class="p">,</span> <span class="n">upperlim</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.rescale_intensity"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.rescale_intensity">[docs]</a>    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">rescale_intensity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">in_range</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;0%&quot;</span><span class="p">,</span> <span class="s2">&quot;100%&quot;</span><span class="p">),</span> 
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rescale the intensity of the image using skimage.exposure.rescale_intensity().</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_range : two scalar values, default is (0%, 100%)</span>
<span class="sd">            Range of lower/upper limit.</span>
<span class="sd">        dtype : numpy dtype, default is np.uint16</span>
<span class="sd">            Output dtype.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Rescaled image with temporal attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">lowerlim</span><span class="p">,</span> <span class="n">upperlim</span> <span class="o">=</span> <span class="n">_check_clip_range</span><span class="p">(</span><span class="n">in_range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            
        <span class="n">out</span> <span class="o">=</span> <span class="n">skexp</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="n">lowerlim</span><span class="p">,</span> <span class="n">upperlim</span><span class="p">),</span> <span class="n">out_range</span><span class="o">=</span><span class="s2">&quot;dtype&quot;</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="ImgArray.track_drift"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.track_drift">[docs]</a>    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">track_drift</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">along</span><span class="p">:</span> <span class="n">AxisLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_drift</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
        <span class="n">upsample_factor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MarkerFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate yx-directional drift using the method equivalent to</span>
<span class="sd">        ``skimage.registration.phase_cross_correlation``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        along : AxisLike, optional</span>
<span class="sd">            Along which axis drift will be calculated.</span>
<span class="sd">        show_drift : bool, default is False</span>
<span class="sd">            If True, plot the result.</span>
<span class="sd">        upsample_factor : int, default is 10</span>
<span class="sd">            Up-sampling factor when calculating phase cross correlation.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkerFrame</span>
<span class="sd">            DataFrame structure with x,y columns</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="kn">from</span> <span class="nn">..frame</span> <span class="kn">import</span> <span class="n">MarkerFrame</span>
        
        <span class="k">if</span> <span class="n">along</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">along</span> <span class="o">=</span> <span class="n">find_first_appeared</span><span class="p">(</span><span class="s2">&quot;tpzcia&quot;</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">along</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`along` must be single character.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">upsample_factor</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upsample-factor must be integer but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">upsample_factor</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">along</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">along</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">last_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">img_fft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">c_axes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">img_fft</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">along</span><span class="p">)):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">last_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span>
                    <span class="n">_corr</span><span class="o">.</span><span class="n">subpixel_pcc</span><span class="p">(</span><span class="n">last_img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">upsample_factor</span><span class="o">=</span><span class="n">upsample_factor</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">last_img</span> <span class="o">=</span> <span class="n">img</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">last_img</span> <span class="o">=</span> <span class="n">img</span>
        
        <span class="n">result</span> <span class="o">=</span> <span class="n">MarkerFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="n">c_axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_drift</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">._utils</span> <span class="kn">import</span> <span class="n">_plot</span> <span class="k">as</span> <span class="n">_plt</span>
            <span class="n">_plt</span><span class="o">.</span><span class="n">plot_drift</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        
        <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">along</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="ImgArray.drift_correction"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.drift_correction">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">drift_correction</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shift</span><span class="p">:</span> <span class="n">Coords</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ref</span><span class="p">:</span> <span class="n">ImgArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">zero_ave</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">along</span><span class="p">:</span> <span class="n">AxisLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
        <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drift correction using iterative Affine translation. If translation vectors ``shift``</span>
<span class="sd">        is not given, then it will be determined using ``track_drift`` method of ImgArray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shift : DataFrame or (N, D) array, optional</span>
<span class="sd">            Translation vectors. If DataFrame, it must have columns named with all the symbols</span>
<span class="sd">            contained in ``dims``.</span>
<span class="sd">        ref : ImgArray, optional</span>
<span class="sd">            The reference n-D image to determine drift, if ``shift`` was not given.</span>
<span class="sd">        zero_ave : bool, default is True</span>
<span class="sd">            If True, average shift will be zero.</span>
<span class="sd">        along : AxisLike, optional</span>
<span class="sd">            Along which axis drift will be corrected.</span>
<span class="sd">        {dims}{update}</span>
<span class="sd">        affine_kwargs :</span>
<span class="sd">            Keyword arguments that will be passed to ``warp``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Corrected image.</span>
<span class="sd">            </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Drift correction of multichannel image using the first channel as the reference.</span>
<span class="sd">            &gt;&gt;&gt; img.drift_correction(ref=img[&quot;c=0&quot;])</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        
        <span class="k">if</span> <span class="n">along</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">along</span> <span class="o">=</span> <span class="n">find_first_appeared</span><span class="p">(</span><span class="s2">&quot;tpzcia&quot;</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">along</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`along` must be single character.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">shift</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># determine &#39;ref&#39;</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">ImgArray</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;ref&#39; must be an ImgArray object, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">axes</span> <span class="o">!=</span> <span class="p">[</span><span class="n">along</span><span class="p">]</span> <span class="o">+</span> <span class="n">dims</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
                <span class="n">_c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">([</span><span class="n">along</span><span class="p">]</span> <span class="o">+</span> <span class="n">dims</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">axes</span><span class="p">))</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">get_formatter</span><span class="p">(</span><span class="n">_c_axes</span><span class="p">)</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">_c_axes</span><span class="p">)):</span>
                    <span class="n">sl</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span><span class="o">.</span><span class="n">drift_correction</span><span class="p">(</span>
                        <span class="n">ref</span><span class="o">=</span><span class="n">ref</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span> <span class="n">zero_ave</span><span class="o">=</span><span class="n">zero_ave</span><span class="p">,</span> <span class="n">along</span><span class="o">=</span><span class="n">along</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
                        <span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">out</span>

            <span class="n">shift</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">track_drift</span><span class="p">(</span><span class="n">along</span><span class="o">=</span><span class="n">along</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">along</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shift</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong shape of `shift`.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">zero_ave</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
        <span class="n">out</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">t_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisof</span><span class="p">(</span><span class="n">along</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># Affine transformation matrix</span>
        <span class="n">input_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_filter</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">input_img</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)):</span>
            <span class="n">mx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">shift</span><span class="p">[</span><span class="n">sl</span><span class="p">[</span><span class="n">t_index</span><span class="p">]]</span>
            <span class="n">out</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">_transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">prefilter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="ImgArray.estimate_sigma"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.estimate_sigma">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">estimate_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">squeeze</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PropArray</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wavelet-based estimation of Gaussian noise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        squeeze : bool, default is True</span>
<span class="sd">            If True and output can be converted to a scalar, then convert it.</span>
<span class="sd">        {dims}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PropArray or float</span>
<span class="sd">            Estimated standard deviation. sigma[&quot;t=0;c=1&quot;] means the estimated value of</span>
<span class="sd">            image slice at t=0 and c=1.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">c_axes</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">skres</span><span class="o">.</span><span class="n">estimate_sigma</span><span class="p">,</span>
            <span class="n">c_axes</span><span class="o">=</span><span class="n">c_axes</span><span class="p">,</span>
            <span class="n">drop_axis</span><span class="o">=</span><span class="n">dims</span>
        <span class="p">)</span>
            
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">squeeze</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">PropArray</span><span class="p">(</span>
                <span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">c_axes</span><span class="p">,</span> <span class="n">propname</span><span class="o">=</span><span class="s2">&quot;estimate_sigma&quot;</span>
            <span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_set_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="n">c_axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>       </div>
        
    
<div class="viewcode-block" id="ImgArray.pad"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.pad">[docs]</a>    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">pad</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">pad_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> 
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">mode</span><span class="p">:</span> <span class="n">PaddingMode</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pad image only for spatial dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pad_width, mode, **kwargs : </span>
<span class="sd">            See documentation of np.pad().</span>
<span class="sd">        dims : int or str, optional</span>
<span class="sd">            Which dimension to pad.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Padded image.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Suppose ``img`` has zyx-axes.</span>
<span class="sd">        </span>
<span class="sd">        1. Padding 5 pixels in zyx-direction:</span>
<span class="sd">            &gt;&gt;&gt; img.pad(5)</span>
<span class="sd">        2. Padding 5 pixels in yx-direction:</span>
<span class="sd">            &gt;&gt;&gt; img.pad(5, dims=&quot;yx&quot;)</span>
<span class="sd">        3. Padding 5 pixels in yx-direction and 2 pixels in z-direction:</span>
<span class="sd">            &gt;&gt;&gt; img.pad([(5,5), (4,4), (4,4)])</span>
<span class="sd">        4. Padding 10 pixels in z-(-)-direction and 5 pixels in z-(+)-direction.</span>
<span class="sd">            &gt;&gt;&gt; img.pad([(10, 5)], dims=&quot;z&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">pad_width</span> <span class="o">=</span> <span class="n">_misc</span><span class="o">.</span><span class="n">make_pad</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">padimg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">padimg</span></div>
    
<div class="viewcode-block" id="ImgArray.pad_defocus"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.pad_defocus">[docs]</a>    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">pad_defocus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">bg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a z-directional padded image by defocusing the original image. This padding is</span>
<span class="sd">        useful when applying FFT to a 3D image.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kernel : 0-, 1- or 3-dimensional array.</span>
<span class="sd">            If 0- (scalar) or 1-dimensional array was given, this is interpreted as standard</span>
<span class="sd">            deviation of Gaussian kernel. If 3-dimensional array was given, this is directly</span>
<span class="sd">            used as convolution kernel. Other dimension will raise ValueError.</span>
<span class="sd">        depth : int, default is 3</span>
<span class="sd">            Depth of defocusing. For an image with z-axis size L, then output image will have</span>
<span class="sd">            size L + 2*depth.</span>
<span class="sd">        width : int, default is 6</span>
<span class="sd">            Width of defocusing. For an image with yx-shape (M, N), then output image will have</span>
<span class="sd">            shape (M * 2*width, N + 2*width).</span>
<span class="sd">        bg : float, optional</span>
<span class="sd">            Background intensity. If not given, it will calculated as the minimum value of </span>
<span class="sd">            the original image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Padded image.</span>
<span class="sd">            </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        depth = 2</span>
<span class="sd">        </span>
<span class="sd">        .. code-block::</span>
<span class="sd">        </span>
<span class="sd">            ----|   |----| o |--     o ... center of kernel</span>
<span class="sd">            ----| o |----|   |--</span>
<span class="sd">            ++++|   |++++|___|++  &lt;- the upper edge of original image </span>
<span class="sd">            ++++|___|+++++++++++</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="n">_check_bg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bg</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">kernel</span><span class="p">):</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kernel</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">filter_func</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">_filters</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">bg</span><span class="p">))</span>
            <span class="n">dz</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">*</span><span class="mi">3</span> <span class="c1"># 3-sigma</span>
            
        <span class="k">elif</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">filter_func</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">xp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">_filters</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">bg</span><span class="p">))</span>
            <span class="n">dz</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`kernel` only take 0, 1, 3 dimensional array as an input.&quot;</span><span class="p">)</span>
        
        <span class="n">pad_width</span> <span class="o">=</span> <span class="p">[(</span><span class="n">depth</span><span class="p">,</span> <span class="n">depth</span><span class="p">),</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">)]</span>
        <span class="n">padimg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">bg</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="s2">&quot;zyx&quot;</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">padimg</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># convolve psf</span>
        <span class="n">z_edge0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">z_mid</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="o">-</span><span class="n">depth</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">z_edge1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">depth</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">y_edge0</span> <span class="o">=</span> <span class="n">x_edge0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">y_mid</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="o">-</span><span class="n">width</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">y_edge1</span> <span class="o">=</span> <span class="n">x_edge1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">width</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">padimg</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">complement_axes</span><span class="p">(</span><span class="s2">&quot;zyx&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)):</span>
            <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
            <span class="n">out_</span><span class="p">[</span><span class="n">z_edge0</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">img</span><span class="p">[:</span><span class="n">depth</span><span class="o">+</span><span class="n">dz</span> <span class="p">])[</span><span class="n">z_edge0</span><span class="p">]</span>
            <span class="n">out_</span><span class="p">[</span><span class="n">z_edge1</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="o">-</span><span class="n">depth</span><span class="o">-</span><span class="n">dz</span><span class="p">:])[</span><span class="n">z_edge1</span><span class="p">]</span>
            <span class="n">out_</span><span class="p">[</span><span class="n">z_mid</span><span class="p">,</span> <span class="n">y_edge0</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:</span><span class="n">width</span><span class="o">+</span><span class="n">dy</span> <span class="p">])[</span><span class="n">z_mid</span><span class="p">,</span> <span class="n">y_edge0</span><span class="p">]</span>
            <span class="n">out_</span><span class="p">[</span><span class="n">z_mid</span><span class="p">,</span> <span class="n">y_edge1</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="o">-</span><span class="n">width</span><span class="o">-</span><span class="n">dy</span><span class="p">:])[</span><span class="n">z_mid</span><span class="p">,</span> <span class="n">y_edge1</span><span class="p">]</span>
            <span class="n">out_</span><span class="p">[</span><span class="n">z_mid</span><span class="p">,</span> <span class="n">y_mid</span><span class="p">,</span> <span class="n">x_edge0</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">width</span><span class="o">+</span><span class="n">dx</span> <span class="p">])[</span><span class="n">z_mid</span><span class="p">,</span> <span class="n">y_mid</span><span class="p">,</span> <span class="n">x_edge0</span><span class="p">]</span>
            <span class="n">out_</span><span class="p">[</span><span class="n">z_mid</span><span class="p">,</span> <span class="n">y_mid</span><span class="p">,</span> <span class="n">x_edge1</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="n">width</span><span class="o">-</span><span class="n">dx</span><span class="p">:])[</span><span class="n">z_mid</span><span class="p">,</span> <span class="n">y_mid</span><span class="p">,</span> <span class="n">x_edge1</span><span class="p">]</span>
            
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="ImgArray.wiener"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.wiener">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">wiener</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">psf</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">lmd</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classical wiener deconvolution. This algorithm has the serious ringing problem</span>
<span class="sd">        if parameters are set to wrong values.</span>
<span class="sd">        </span>
<span class="sd">        :math:`F[Y_{res}] = \frac{F[Y_{obs}] \cdot \bar{H}}{|H|^2 + \lambda}`</span>
<span class="sd">            </span>
<span class="sd">        :math:`Y_{obs}`: observed image;</span>
<span class="sd">        :math:`Y_{res}`: restored image;</span>
<span class="sd">        :math:`H` : FFT of point spread function (PSF);</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        psf : np.ndarray</span>
<span class="sd">            Point spread function.</span>
<span class="sd">        lmd : float, default is 0.1</span>
<span class="sd">            Constant value used in the deconvolution. See Formulation below.</span>
<span class="sd">        {dims}{update}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Deconvolved image.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        lucy</span>
<span class="sd">        lucy_tv</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="n">lmd</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lmd must be positive, but got: </span><span class="si">{</span><span class="n">lmd</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">psf_ft</span><span class="p">,</span> <span class="n">psf_ft_conj</span> <span class="o">=</span> <span class="n">_deconv</span><span class="o">.</span><span class="n">check_psf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_deconv</span><span class="o">.</span><span class="n">wiener</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">psf_ft</span><span class="p">,</span> <span class="n">psf_ft_conj</span><span class="p">,</span> <span class="n">lmd</span><span class="p">)</span>
        <span class="p">)</span></div>
        
    
<div class="viewcode-block" id="ImgArray.lucy"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.lucy">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">lucy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">psf</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">niter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deconvolution of N-dimensional image, using Richardson-Lucy&#39;s algorithm.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        psf : np.ndarray</span>
<span class="sd">            Point spread function.</span>
<span class="sd">        niter : int, default is 50.</span>
<span class="sd">            Number of iterations.</span>
<span class="sd">        eps : float, default is 1e-5</span>
<span class="sd">            During deconvolution, division by small values in the convolve image of estimation and </span>
<span class="sd">            PSF may cause divergence. Therefore, division by values under `eps` is substituted</span>
<span class="sd">            to zero.</span>
<span class="sd">        {dims}{update}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Deconvolved image.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        lucy_tv</span>
<span class="sd">        wiener</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">psf_ft</span><span class="p">,</span> <span class="n">psf_ft_conj</span> <span class="o">=</span> <span class="n">_deconv</span><span class="o">.</span><span class="n">check_psf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_deconv</span><span class="o">.</span><span class="n">richardson_lucy</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">psf_ft</span><span class="p">,</span> <span class="n">psf_ft_conj</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="p">)</span></div>
        
<div class="viewcode-block" id="ImgArray.lucy_tv"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.ImgArray.lucy_tv">[docs]</a>    <span class="nd">@_docs</span><span class="o">.</span><span class="n">write_docs</span>
    <span class="nd">@dims_to_spatial_axes</span>
    <span class="nd">@same_dtype</span><span class="p">(</span><span class="n">asfloat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@check_input_and_output</span>
    <span class="k">def</span> <span class="nf">lucy_tv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">psf</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">lmd</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImgArray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deconvolution of N-dimensional image, using Richardson-Lucy&#39;s algorithm with</span>
<span class="sd">        total variance regularization (so called RL-TV algorithm). The TV regularization</span>
<span class="sd">        factor at pixel position :math:`x`, :math:`F_{reg}(x)`, is calculated as:</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            F_{reg}(x) = \frac{1}{1-\lambda \cdot div(\frac{grad(I(x)}{|grad(I(x))|})}</span>
<span class="sd">        </span>
<span class="sd">        (:math:`I(x)`: image, :math:`\lambda`: constant)</span>
<span class="sd">        </span>
<span class="sd">        and this factor is multiplied for every estimation made in each iteration.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        psf : np.ndarray</span>
<span class="sd">            Point spread function.</span>
<span class="sd">        max_iter : int, default is 50.</span>
<span class="sd">            Maximum number of iterations.</span>
<span class="sd">        lmd : float, default is 1e-3</span>
<span class="sd">            The constant lambda of TV regularization factor.</span>
<span class="sd">        tol : float, default is 1e-3</span>
<span class="sd">            Iteration stops if regularized absolute summation is lower than this </span>
<span class="sd">            value.</span>
<span class="sd">            </span>
<span class="sd">            :math:`\frac{\sum_{x}|I&#39;(x) - I(x)|}{\sum_{x}|I(x)|}`</span>
<span class="sd">            </span>
<span class="sd">            (:math:`I&#39;(x)`: estimation of :math:`k+1`-th iteration, :math:`I(x)`: </span>
<span class="sd">            estimation of :math:`k`-th iteration)</span>
<span class="sd">        </span>
<span class="sd">        eps : float, default is 1e-5</span>
<span class="sd">            During deconvolution, division by small values in the convolve image of</span>
<span class="sd">            estimation and PSF may cause divergence. Therefore, division by values </span>
<span class="sd">            under ``eps`` is substituted to zero.</span>
<span class="sd">        {dims}{update}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImgArray</span>
<span class="sd">            Deconvolved image.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - Dey, N., Blanc-Féraud, L., Zimmer, C., Roux, P., Kam, Z., Olivo-Marin, J. C., </span>
<span class="sd">          &amp; Zerubia, J. (2004). 3D microscopy deconvolution using Richardson-Lucy algorithm </span>
<span class="sd">          with total variation regularization (Doctoral dissertation, INRIA).</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        lucy</span>
<span class="sd">        wiener</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lmd</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;In Richadson-Lucy with total-variance-regularization, &quot;</span>
                <span class="s2">&quot;parameter `lmd` must be positive.&quot;</span>
            <span class="p">)</span>
        <span class="n">psf_ft</span><span class="p">,</span> <span class="n">psf_ft_conj</span> <span class="o">=</span> <span class="n">_deconv</span><span class="o">.</span><span class="n">check_psf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_dask</span><span class="p">(</span>
            <span class="n">_deconv</span><span class="o">.</span><span class="n">richardson_lucy_tv</span><span class="p">,</span> 
            <span class="n">c_axes</span><span class="o">=</span><span class="n">complement_axes</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">psf_ft</span><span class="p">,</span> <span class="n">psf_ft_conj</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">lmd</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_check_coordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">ImgArray</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">impy.frame</span> <span class="kn">import</span> <span class="n">MarkerFrame</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">MarkerFrame</span><span class="p">):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coords</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">coords</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input cannot be interpreted as coordinate(s).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ndim</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">axes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="n">complement_axes</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">axes</span><span class="p">)[</span><span class="o">-</span><span class="n">ndim</span><span class="p">:]</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">MarkerFrame</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
        <span class="n">coords</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">coords</span>

<span class="k">def</span> <span class="nf">_check_function</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must be one of numpy methods or callable object.&quot;</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">_check_bg</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">ImgArray</span><span class="p">,</span> <span class="n">bg</span><span class="p">):</span>
    <span class="c1"># determine bg</span>
    <span class="k">if</span> <span class="n">bg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bg</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">):</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">bg</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bg</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Wrong type of `bg`.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bg</span>

<span class="k">def</span> <span class="nf">_check_template</span><span class="p">(</span><span class="n">template</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`template` must be np.ndarray, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">template</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">template</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`template must be 2 or 3 dimensional.`&quot;</span><span class="p">)</span>
    <span class="n">template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">template</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">template</span>

<span class="k">def</span> <span class="nf">_calc_centroid</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndim</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">mom</span> <span class="o">=</span> <span class="n">skmes</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mom</span><span class="p">[(</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">ndim</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> 
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)])</span> <span class="o">/</span> <span class="n">mom</span><span class="p">[(</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="n">ndim</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">centroid</span>

<span class="k">def</span> <span class="nf">_check_clip_range</span><span class="p">(</span><span class="n">in_range</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Called in clip_outliers() and rescale_intensity().</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">in_range</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lower</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">):</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lower</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lowerlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">lower</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lowerlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lowerlim</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">upper</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">):</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">upper</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">upperlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">upper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upperlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upperlim</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">lowerlim</span> <span class="o">&gt;=</span> <span class="n">upperlim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lowerlim is larger than upperlim: </span><span class="si">{</span><span class="n">lowerlim</span><span class="si">}</span><span class="s2"> &gt;= </span><span class="si">{</span><span class="n">upperlim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">lowerlim</span><span class="p">,</span> <span class="n">upperlim</span>

<span class="k">def</span> <span class="nf">_specify_one</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span><span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">slice</span><span class="p">]:</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xc</span><span class="o">-</span><span class="n">r</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">xc</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">sh</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span> 
                        <span class="k">for</span> <span class="n">xc</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">sh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">sl</span>

<div class="viewcode-block" id="check_filter_func"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.check_filter_func">[docs]</a><span class="k">def</span> <span class="nf">check_filter_func</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`filt` must be callable.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="wave_num"><a class="viewcode-back" href="../../../apidoc/impy.arrays.html#impy.arrays.imgarray.wave_num">[docs]</a><span class="k">def</span> <span class="nf">wave_num</span><span class="p">(</span><span class="n">sl</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">uf</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function that makes wave number vertical vector. Returned vector will</span>
<span class="sd">    be [k/s, (k + 1/uf)/s, (k + 2/uf)/s, ...] (where k = sl.start)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sl : slice</span>
<span class="sd">        Slice that specify which part of the image will be transformed.</span>
<span class="sd">    s : int</span>
<span class="sd">        Size along certain dimension.</span>
<span class="sd">    uf : int</span>
<span class="sd">        Up-sampling factor of certain dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">sl</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sl</span><span class="o">.</span><span class="n">start</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">s</span> <span class="k">if</span> <span class="n">sl</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sl</span><span class="o">.</span><span class="n">stop</span>
    
    <span class="k">if</span> <span class="n">sl</span><span class="o">.</span><span class="n">start</span> <span class="ow">and</span> <span class="n">sl</span><span class="o">.</span><span class="n">stop</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># like &quot;x=-5:5&quot;</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">s</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid value encountered in slice </span><span class="si">{</span><span class="n">sl</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">stop</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">+=</span> <span class="n">s</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">stop</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid value encountered in slice </span><span class="si">{</span><span class="n">sl</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
    <span class="n">n</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">return</span> <span class="n">xp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">uf</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Hanjin Liu.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>